[{"categories":["Deno"],"content":"视频记录了我基于Deno Web 框架 oak 使用 TDD的方式写的一个简单的工程化的 demo。 ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:0:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于Deno的一次TDD实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["Deno"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.Bilibili ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:1:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于Deno的一次TDD实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["Deno"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:2:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于Deno的一次TDD实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["TDD"],"content":"Window对象的各种测试方法总结","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"前言 在平时前端项目开发中有很多需要对window对象进行进行操作，比如改变window.location.href的值，在前端页面中，这会使浏览器发生页面跳转，还有如window.location.replace(), 那么在测试中，虽然 jest 会有部分初始值，但有时候我们需要明确给定值，让测试更明确。 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:1:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Window 对象测试分析 window 对象有属性(property)和方法(method), 在此我们以href, window.location.href + hash 和 postMessage几个特性来测试， 对每个类型(property/method)将使用至少三种方法来展示，测试方法可以分为如下四类： delete - 在原对象window上进行测试 Object.defineProperty - 重新定义属性 mockfile - mock 整个被测文件 spyOn - 对特定方法进行mock ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:2:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"被测文件 在这可以不用遵循TDD的流程，直接给出被测文件内容, 也可在github export const changeHref = (value: string) =\u003e { window.location.href = value } export const addHash = (hash: string): string =\u003e { return window.location.href + `#${hash}` } export const sendMessage = (message) =\u003e { window.top.postMessage({ type: 'message', data: message, }, '*' ) } ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:3:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"测试 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"property - changeHref delete import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location }) afterEach(() =\u003e { window.location = location }) it('should change href to http://test.com when newURL is http://test.com', () =\u003e { const newURL = \"http://test.com\" window.location = { ...location, href: '' } changeHref(newURL) expect(window.location.href).toBe(newURL) }) }) Object.defineProperty import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) spyOn import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:1","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - addHash delete import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location; window.location = { ...location, href: 'http://href.com' } }) afterEach(() =\u003e { window.location = location }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) Object.defineProperty import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { Object.defineProperty(window, 'location', { value: { ...location, href: 'http://href.com', }, }) }) afterEach(() =\u003e { Object.defineProperty(window, 'location', location) }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) mockFile import * as attribute from '../src/attribute' jest.mock('../src/attribute', () =\u003e { return { __esModule: true, addHash: jest.fn(), }; }); beforeEach( () =\u003e { jest.resetModules(); }) describe('method', () =\u003e { it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(attribute.addHash)).toBe(true); }); it('verify method has been invoked', () =\u003e { expect(attribute.addHash).not.toHaveBeenCalled(); // will failed // expect(attribute.addHash('test')).toEqual('http://localhost/#test') attribute.addHash('234') expect(attribute.addHash).toHaveBeenCalled() expect(attribute.addHash).toBeCalledTimes(1) expect(attribute.addHash).toBeCalledWith('234') }) }) spyOn import { addHash } from '../src/attribute' describe('method', () =\u003e { let windowSpy beforeEach(() =\u003e { windowSpy = jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e { windowSpy.mockRestore() }) it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(windowSpy)).toBe(true) }); it('spyOn for addHash', () =\u003e { windowSpy.mockImplementation(() =\u003e ({ href: 'http://test.com', })) expect(windowSpy).not.toHaveBeenCalled() expect(addHash('123')).toEqual('http://test.com#123') expect(windowSpy).toHaveBeenCalled(); }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:2","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - postMessage import {sendMessage} from '../src/attribute' describe('multiple', () =\u003e { it('sendMessage test with multiple test method', () =\u003e { Object.defineProperty(window, 'top', { value: window, writable: true, enumerable: true, configurable: true, }) Object.defineProperty(window, 'postMessage', { writable: true, value: jest.fn(), }) sendMessage('message') expect(window.parent.postMessage).toHaveBeenCalled() expect(window.parent.postMessage).toBeCalledTimes(1) }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:3","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"总结 总结就是整理自己，方便自己，如若能方便他人，那就是意外了。 源代码：https://github.com/AndorLab/test-window-object ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:5:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.mock-window-location 4.jest-how-to-mock-window-location-href 5.Global Object defineProperty 6.test double ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:6:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:7:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["Rust"],"content":"问题 ❯ cargo run error: failed to run `rustc` to learn about target-specific information Caused by: process didn't exit successfully: `rustc - --crate-name ___ --print=file-names -Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit code: 1) --- stderr error: the option `Z` is only accepted on the nightly compiler` 最近更新了rust, 然后运行cargo run, 莫名其妙的出现了上面的问题。 ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"原因 在 rust 官网的 issue 里找解决方案，都是open 状态的，没有实际意义。那么就得回到原始方式。 按照提示，说Z 这个参数仅适用于nightly版本的 rust 编译器，但是我用的是stable版本的rust; ❯ rustup show Default host: x86_64-apple-darwin rustup home: /Users/c4/.rustup stable-x86_64-apple-darwin (default) rustc 1.44.0 (49cae5576 2020-06-01) 版本确定，那么只能将语音归结到命令行某个地方有注入参数。第一个想到的就是环境变量，打开我的~/.zshrc, 果然在最下面找到了这么一条记录, 看到-Z, 应该就是他了。 export RUSTFLAGS=\"-Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort\" ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:2:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"解决方案 删除该行记录，运行程序，成功输出hello world。 ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:3:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3. grcov ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:4:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:5:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Deno"],"content":"引子 有些时候，软件开发过程中没有将系统功能，且分开从而将系统拆分为多个子系统，或者在自身系统开发过程中有必须要依赖的外部服务，那么对外提供服务的时候就得让所有的子服务都得随时候命， 排列起来就像古代战场的对战状态一样了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:1:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"存在的问题 对于这种情况存在什么问题呢？ 想象一个场景，作为老板或者业务对接方，我要集成和之前一样的系统，我要对接这么多接口么？如果对接方看到这么多的系统接口要对接，他肯定就放弃治疗了。 总结一下存在的问题。 对接系统接口较多，还可能对接很多个域名 作为对接方，系统接口出了问题，我得看是哪个系统出问题了，还得去找对应的对接方 不同的接口，可能存在不同的甩锅行为 乱，新人很难很快上手 多则乱，乱则要花很多钱 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:2:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"解决方案 对于上面提到的各种问题，我们有什么解决方案呢？ 最近，微服务的概念比较流行， 我们想想一下前端微服务是怎么组合的？是不是将很多个子页面服务都集成在一个一面中，最终这个页面为用户服务。让这个页面作为对接点。结合上面的图，我们可以设计如下图的方案， 抽离一个中间层，我们暂时可以称之为 Platform， 让所有的资源都从Platform进和出，将要集成的各种服务屏蔽在Platform后面，对于对接方，他永远只知道一个Platform， 这样集成起来就好多了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:3:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Coding 方案也有了，那么接下来就是撸起袖子加油干的时候了。 因为 Platform 会是一个后端的工程，其对外提供各种接口和资源；最近Deno比较🔥，为了尝试真香定律， 我们就拿它来实践一下。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"业务 对于后端请求另一个后端接口，将请求的结果再返回给请求者，这个很容易实现， 我们就不实现了；那么我们来做一个不同的操作。 业务流程 某个后端提供前端资源， 这个资源是由这个后端服务团队维护，且这个服务需要在前端使用 在此， 我们将这个后端资源暂时抽象为jquery.js, 提供jquery.js服务的团队就是被我们 Platform 屏蔽起来的服务团队， 对我们本次实践来说就是某一个提供Jquery的CDN服务商。 具体的Code 在此，如有需要可随时查看。在实现过程中也有两种方案， 资源请求的前端页面代码如下, 重点就是 script标签中src的获取是一个 GET请求！ \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"http://localhost:8000/custom/domain/jquery.js\"\u003e\u003c/script\u003e \u003c/head\u003e 方案1 // handlers/fetchJquery.ts export const redirect = async ({ response }: { response: Response }) =\u003e { response.redirect(jqueryUrl) } 这种方案是将资源的请求转发到jquery的资源服务地址上，让浏览器自动302跳转到该地址，进行资源获取。 方案2 // handlers/fetchJquery.ts export const getContent = async ({ response }: { response: Response }) =\u003e { response.body = await fetchResponse(jqueryUrl); }; // services/fetchResource.ts export default async (url: string) =\u003e { return fetch(url).then((res) =\u003e res.body); }; 这种方案是将资源请求到服务器，然后将资源再返回给前端。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:1","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"总结 对于这两种方案，更加推荐第一种；第一种方案将资源的路径返回给前端然后由浏览器做跳转并将资源请求回来， 而第二种需要将资源请求回来，如果该资源的请求量比较大，那么就得做缓存，相比于第一种，第二种 Platform 在后期维护也不好,而且压力会在Platform和被屏蔽的服务那里，多了不必要的麻烦。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:5:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.ForwardJS 4.了不起的 Deno 实战教程 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:6:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":[""],"content":"go 的 import 其实是去GOROOT下去加载你写的模块，当然Go的import还支持如下两种方式来加载自己写的模块： 相对路径 import \"./model\" //当前文件同一目录的model目录，但是不建议这种方式import 绝对路径 import \"shorturl/model\" //加载GOPATH/src/shorturl/model模块 上面展示了一些import常用的几种方式，但是还有一些特殊的import，让很多新手很费解，下面是三种导入包的使用方法。 点操作 有时候会看到如下的方式导入包 import( . “fmt” ), 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”) 可以省略的写成Println(“hello world”) 别名操作 别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字 import( f “fmt” ) 别名操作调用包函数时前缀变成了重命名的前缀，即f.Println(“hello world”) _操作 这个操作经常是让很多人费解的一个操作符，请看下面这个import import ( “database/sql” _ “github.com/ziutek/mymysql/godrv” _操作其实只是引入该包。当导入一个包时，它所有的init()函数就会被执行，但有些时候并非真的需要使用这些包，仅仅是希望它的init()函数被执行而已。这个时候就可以使用_操作引用该包了。即使用_操作引用包是无法通过包名来调用包中的导出函数，而是只是为了简单的调用其init函数()。 ","date":"2020-05-16","objectID":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/:0:0","tags":[""],"title":"Go Import相关操作","uri":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"categories":[""],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ ","date":"2020-05-16","objectID":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/:1:0","tags":[""],"title":"Go Import相关操作","uri":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"categories":[""],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-05-16","objectID":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/:2:0","tags":[""],"title":"Go Import相关操作","uri":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"categories":[""],"content":"产品的特性 要像牙刷，高频切实用 对用户一定要有价值，如谷歌搜索, 反面教材如百度 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"协作 协作的基础是对知识点的认同 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"个人品牌 个人魅力，个人品牌 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"解决问题 阐述问题，探寻本质，给出解决方案 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"知识点 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"马尔萨斯陷阱 200多年前，英国经济学家马尔萨斯提出，人口按几何级数增长，而粮食只能按算术级数增长。这样，人口增加到一定程度便出现粮食紧缺、人地矛盾，不可避免地反复出现饥馑、战争和疾病。（《人口原理》，马尔萨斯）， 举例：黑死病、西班牙大流感的传染病，伯罗奔尼撒战争、百年战争、一战二战的大规模战争，孟加拉大饥荒、印度大饥荒的大灾难 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:1","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"前言 学习Rust肯定离不开查看其官方或者第三方开发者的文档，而在Rust 的crate中，对于开发者或者使用者，文档是非常友好的。在这就不举例了。本文主要是记录一下写rust doc的一些小步骤。方便日后查阅。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:1:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"示例 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"生成项目 $ cargo new mylib --lib ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:1","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"编写lib.rs中的实现 pubfn add_one(x: i32)-\u003e i32 {x+1} ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:2","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"为 add_one 添加注释 最终效果如下： //! My Crate name //! //! `my_crate_name` is test for studying /// Add one for the number given /// /// #Example /// /// ```rust ///let five = 5 ///assert_eq!(6, rust_study::add_one(five)); /// ``` /// pubfn add_one(x: i32)-\u003e i32 {x+1} ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:3","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"生成rust 标准文档并查看 $ cargo doc --open 执行如上命令，cargo会根据注释生成web网页文档，并且自动打开，如下是上面文档生成的结果。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:4","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"总结 Rust 中写的注释代码，可以用来做方法示例，或者当作测试，如果是测试，运行cargo test , cargo 不仅会测试tests文件夹下的测试案例，还会寻找注释中的测试。 什么时候写注释呢？优秀的程序员总是强调方法名即注释等。但有不确定的时候就得写注释啦。 在rust中，在程序会panic的时候需要写注释告诉调用者可能panic的方法 返回值是Result类型的时候，需要告诉调用者，Ok 和 Err的数据会是什么 Rust 的编译器相当严谨，结合TDD 写代码应该会很爽。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:3:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:4:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:5:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Summary"],"content":"插曲 去年与前ThoughtWorks 咨询师 李小波的一次线下交流中，学习到了总结知识的一点技巧，非常受用，并且在交流后得到了小波老西自己整理的知识图谱，在自己不断积累下，有文字，也又图片。最近在整理知识，同时也在乱搞知识分享平台。自己虽然有这个博客，但是感觉有些东西不是博客所能呈现的，比如思维导图，我收集的各种模型图等。 之前为了给社区做宣传海报等内容，学会了Adobe XD, 去年年中前，中国区是可以访问Adobo XD 的云文档的，后半年就不行了，必须要重新注册或者更换绑定到国外的初始注册站点才可以使用云文档，这也导致了我有一部分资源永远的留在了遥不可及的Adobe 服务器上。 对我这种穷人很不友好， 😂😂😂😂😂😂😂, 那么我就得需要找个地方薅羊毛了。 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:1:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"Figma 某天记起听过的一篇anyway的podcast里提到过Figma, 据说有免费的资源可以使用，上去一看，果然for up to 2 editors and 3 projects 这样的免费套餐对于我这样的小菜鸟完全足够用了，而且我还邀请了另一个小伙伴，人数刚刚好，😄 当然我也不怕资源丢失，我把我的设计文档同步到了icloud上，再也不用担心Adobe XD的悲剧了。 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:2:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"附加值 选了Figma，其实还有其他原因; 它完全支持桌面，网页和移动端，可以在各个端进行创作 将成果保存在云端，或者直接发布到avocode, zeplin和Dribble 支持插件，完美集成各种小工具 支持导出图片到原型网站如zeplin, 当然这点是相对与Adobe XD的，我还没发现Adobe XD 的这个功能 很多大厂的选择 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:3:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"成果 经过整理，我将我的知识模型总结放在了Figma上，地址如下，并将其分享到了zeplin上，可以在zeplin上在线查看，学习或者别人查看的时候也是很方便。 知识图谱 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:4:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"Reference 1.博客: https://guzhongren.github.io/ 2.图床: https://sm.ms/ 3.Figma: https://www.figma.com/ 4.Zeplin: https://app.zeplin.io/ ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:5:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:6:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Language"],"content":"在鲁迅的文章《孔乙己》中说，茴香豆的茴字有好几种写法，记得没错的话应该是四种，具体哪四种请参考下文引用。 在Rust 中，闭包也有好几种写法，今天就来总结一哈。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:0:0","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"闭包的写法 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:1:0","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"闭包语法 fn add_one_v1(x: u32)-\u003e u32 {x+1}letadd_one_v2=|x: u32|-\u003e u32 {x+1};letadd_one_v3=|x|{x+1};letadd_one_v4=|x|x+1; ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:1:1","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"使用闭包 leta=add_one_v1(5);letb=add_one_v2(5);letc=add_one_v3(5);letd=add_one_v4(5);println!(\"a={}, b={}, c={}, d={}\",a,b,c,d); 执行cargo run会得到如下结果： a=6, b=6, c=6, d=6 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:1:2","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"重点说明 闭包定义会为每个参数和返回值类型推导一个具体的类型，但是不能推导两次(不能让俩次或多次使用是不同类型的参数进行调用) 语言描述有点模糊，那么用代码说明问题 // 不能推导两次的示例 letexample_closure=|x|x;lets=example_closure(String::from(\"hello\"));println!(\"第一次{}\",s);// 如果参数为数字5 ，则报错 // let n = example_closure(5); letn=example_closure(5.to_string());println!(\"第二次{}\",n); 在上面我们定义了一个参数为x, 返回值为x的闭包，但是x的类型我们并没有指定。 经过第一次调用，传入参数类型为字符串， 得到的结果s也为字符串 hello, 第二次调用如果传入参数为数字5， 那么程序就会报错，如下 error[E0308]: mismatched types --\u003e src/main.rs:22:29 | 22 | let n = example_closure(5); | ^ | | | expected struct `std::string::String`, found integer | help: try using a conversion method: `5.to_string()` 如果将数字5转换为字符串5，那么程序就运行正常。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:2:0","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"总结 Rust的闭包感觉和js的函数的写法很像，感觉到了Rust又借鉴了部分js的语法。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:3:0","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.图床：https://sm.ms/ 3.茴香豆的茴字的写法：https://zhidao.baidu.com/question/1448503662321920660.html 4.Rust 闭包：https://doc.rust-lang.org/rust-by-example/fn/closures.html ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:4:0","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:5:0","tags":["Rust","Closure","闭包"],"title":"Rust中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Shell"],"content":"最近在做 DevOps 的工作，主要是做一个蓝绿部署的方案，在这部分中涉及到了写 shell， Shell 作为一种程序语言，那么对于开发人员肯定是要在部署到正式或者生产环境前进行调试的，在 coding 过程中，发现 shell 的调试其实和平时写的 JS, Java, Rust 等的调试不同，Shell 只能看你每一步执行的语句，至于具体执行是否正确，得由 coding 的人来写正确；好吧，有点难理解，那么我来举个🌰； ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:0:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"举例 有如下代码 #!/bin/bash set -eu readonly FIRST_VALUE=\"first value\" echo \"你会得到替换后的值：${FIRST_VALUE} 脚本很简单，简单一句话，定义了一个变量FIRST_VALUE， 然后用echo输出，在输出的时候应用了刚才定义的变量FIRST_VALUE，赋予执行权限后，如果执行./run.sh之后，只会在终端输出 你会得到替换后的值：first value 但是在简单的脚本中还可以直接运行，如果运行一个复杂的脚本，那么出问题了的几率击溃比较高了，那么调试脚本积极非常重要了。 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:1:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"debug shell 的调试说来也非常简单，直接运行sh -x ...就可以了，对于本脚本我们执行如下： sh -x run.sh 会得到输出，如下： + set -eu + readonly 'FIRST_VALUE=first value' + FIRST_VALUE='first value' + echo '你会得到替换后的值：first value' 你会得到替换后的值：first value 在这里面，你会看到每条 shell 脚本运行的具体命令，以及参数等内容，这条命令也是一种执行，会对命令涉及的内容产生实际效果，不要以为知识dry run。 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:2:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"总结 好习惯都是踩坑踩出来的 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:3:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.编写可靠bash脚本的一些技巧:https://mp.weixin.qq.com/s/VmM_U4RefRBHwIw8NegC8Q ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:4:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:5:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Summary"],"content":" 一句话的分量是否重，是要看能不能击中听者的痛点。 设计评审过程中，需要各种文档或者其他资料来辅助，在此总结一番，以供后续查阅。 产品PRD：当有疑问时可以拿出来给评审者查看 设计分析文档：用来沟通关于行业内对于同类型功能的设计优缺点的分析 数据分析文档：用来展示当前版本数据上的表现和问题，以及可以帮助进行下一步改善 功能逻辑图：复杂功能可以使用图形化表现功能逻辑，便于评审者理解 用户路径图：通过用户路径讲解全局性问题，结合交互设计稿进行具体说明 交互动效演示文档：用来解释一些比较复杂的交互过程 配色情绪版：用来解释如何选择当前配色的思路 制作的思维导图存放于石墨文档，地址如下 https://shimo.im/mindmaps/ne3VVNJy4Ju8FB3b ","date":"2020-04-04","objectID":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/:0:0","tags":["评审","文档","资料总结"],"title":"设计评审文档指南","uri":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/"},{"categories":["Summary"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.图床：https://sm.ms/ ","date":"2020-04-04","objectID":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/:1:0","tags":["评审","文档","资料总结"],"title":"设计评审文档指南","uri":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/"},{"categories":["Summary"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-04-04","objectID":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/:2:0","tags":["评审","文档","资料总结"],"title":"设计评审文档指南","uri":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/"},{"categories":["Agile"],"content":"本思维导图中大部分内容由@haihaio完成。 此思维导图中总结了TDD 的概念，原则，套路，案例及策略等，不失为一份很好的学习资料。 项目地址: https://github.com/AndorLab/MindKnowledgeGraph 方法论很多，重要的是使用方法论的人～单元测试 – from @haihaio ","date":"2020-04-02","objectID":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/:0:0","tags":[" Agile","tdd","方法论","总结","原则","套路","单元测试"],"title":"开发眼中的TDD","uri":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/"},{"categories":["Agile"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.http://agiledata.org/essays/tdd.html 3.https://opensource.com/article/19/10/test-driven-development-best-practices 4.https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html 5.https://dzone.com/articles/7-popular-unit-test-naming ","date":"2020-04-02","objectID":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/:1:0","tags":[" Agile","tdd","方法论","总结","原则","套路","单元测试"],"title":"开发眼中的TDD","uri":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/"},{"categories":["Agile"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-04-02","objectID":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/:2:0","tags":[" Agile","tdd","方法论","总结","原则","套路","单元测试"],"title":"开发眼中的TDD","uri":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/"},{"categories":["Tool"],"content":" 软件常用常新，软件大多的目的都是效率，办公，沟通，和娱乐等。虽说Mac 也有自己的时间机器，可以随时将新机器回复到旧机器上，但是作为分享和传播，那么写一篇文章那是最有效率的了，也可为自己后期使用做备份。 接下来，我将按照生产力，效率,沟通和娱乐这几类将我Mac上的常用软件列个清单。 生产力 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:0:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Visual Studio Code 从严格意义上来说，VSCode并不算IDE，但是其设计与插件系统非常完美，作为前端起家的我，只要能写代码我就可以创造世界，估计以后还有一篇写插件的博客。 轻量 插件系统非常完善 绝大多数编程语言都支持 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:1:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Vim 作为程序员开发必备利器！ 装逼利器 学习Linux的必备工具 高效编码的工具 任何Linux版本都有的编辑器 定制化程度非常高 …… 在此推荐我的定制的vimrc,地址在这, ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:2:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"iTerm2 Mac 上非常好用的终端，安装之后自带zsh, 而zsh又自带各种好用的快捷方式，比如简化的git命令，zsh的自动补全等插件 界面简洁 自定义配置程度比较高 可搭配不同的命令行主题，在此推荐powerlevel10k 真的比Mac自带的终端好用啊 😄 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:3:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"IDEA Java开发必备 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:4:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"备忘录 备忘录可以随时打开做笔记，记录重要的内容，当然和iPhone配合使用会更高效。主要就是使用自己制作的快捷指令，我的主要有两个，一个是Copy and Paste, 顾名思义，将复制的内容粘贴到备忘录中；第二个顺便记，这个快捷指令会将语音内容转化为文字并将其追加到备忘录中。 使用这两个快捷指令，将非常高效，比如平时记录零碎的知识点，重要的总结内容等。 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:5:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"XMind 思维导图界的翘楚，当然需要付费。 界面简洁赶紧 功能简单但丰富 主题多样，市面上99%的导图类型都实现了 主题真的很好看 可跨平台使用 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:6:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Adobe XD 传统图像大厂Adobe产品，结合 Adobe 全家桶使用应该很爽，需要注意的是在国内，XD不可以使用在线存储服务，所以在注册时记得将地区选择为其他地区，推荐美国🇺🇸， 使用简单，免费，相比与Sketchup, 这点还是很诱人的 中文文档做的也不错 插件系统也不错，可与Trello等工具结合 矢量图形编辑也非常不错 效率 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:7:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Bitwarden 用来存储和生成密码的工具 开源 免费 (有商业版) 支持两步验证(2FA) 可按条件生成随机密码(我从来不记我的密码，而且我也记不住) 多端支持 可自定义数据存储方案 可自动填充账号密码 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:8:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Microsoft Todo 微软收购了Wunderlist, 然后推出了桌面版，Web版，Mobile(Apple, Android), Pad版的Todo应用，我比较看好的功能 只需一个 Microsoft 账号就可以在各个终端进行数据同步 界面清新简洁 可自定义分组，分类 可自定义背景图片 可与其他人共享Todo 最重要的是可以在每一个Todo里定义子Todo 沟通 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:9:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"微信 不管是亲朋还是同事沟通，微信都是非常高效的工具，而且微信里面的小程序现在可以运行在桌面端了，使用场景也越来越多了；还有一个非常好用的功能：截屏！ 以前电脑上会安装QQ， 现在QQ也不用了，快速分享内容并标注微信是不二之选。 娱乐 ##IINA The modern media player for macOS. 开源，免费 支持多种资源播放（在线，本地文件，Youtube等） 界面简洁清爽 操作简单直观 字幕，视频大小可随意调节 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:10:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.Todo: https://todo.microsoft.com/tasks/ 3.Visual Studio Cod: https://code.visualstudio.com/ 4.Vim: https://www.vim.org 5.Vimrc: https://github.com/guzhongren/.vim 6.Bitwarden:https://bitwarden.com/ 7.IDEA: https://www.jetbrains.com/idea/ 8.微信:https://res.wx.qq.com/a/wx_fed/weixin_portal/res/static/img/3sPNXyP.gif 9.IINA:https://iina.io/ 10.Adobe XD: https://www.adobe.com/cn/products/xd.html ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:11:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:12:0","tags":["software","chat","效率","娱乐"],"title":"我的Mac上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Agile"],"content":"场景 最近上了澳洲的项目，项目组9个人，我们的站会是每周有一个人来轮流主持，每天早上10点，在Teams上与澳洲的客户一起面对Jira看板进行工作同步； 上周正好轮值到我了，按照我司的习惯，哪能有搞不定的事啊，如果有，那就是多花点时间的问题了，当然这话是我说的。那么对于英语菜鸟的我是怎么host standup meeting的呢？接下来让我一一道来。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:1:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"方法论 做事最重要的是你要一个什么样的结果，只要知道你要的结果，那么将实现结果的步骤一步步拆解成一个个的Task，这个过程产生的结果也被称为Tasking。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:2:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"Tasking 1.每天练英语听力和口语(提升自己) 2.平时收集工作中遇到的各种单词和短语(提升自己) 3.收集主持站会用到的各种短语(提升自己) 4.对于自己要更新的内容，提前将主要关键词写下来(提升自己) 5.学习并总结别人主持站会的流程(学习总结) 6.与同事交流主持站会的心得(鼓励自己，提升信心) 7.Recycle(量变达到质变) …… 在每个task的后面我都备注了每个task的作用,都很好理解。 对于第1条，我推荐6分钟英语和China Daily;6分钟英语里面有热点新闻的简短介绍和常用场景的对话，虽说是6分钟英语，但真实情况是至少需要15分钟，但还是很值得推荐；China Daily 就不用说了。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:2:1","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"英文场景对话 有了方法论，那么是不是应该将这些内容应用到实战才能检验成果呢？下面我来模拟一场Standup Meeting。 主持站会我们会提前1～2分钟进入会议，调试语音,看板和等待客户等； 客户上线了，问候客户 Hi, xxx, How’s the weather today [Customer]It’s a cloudy/sunny day. How are you? [Customer]I’m fine, thank you ! And you? I’m fine too. Thank you, team is ready, let’s start our standup meeting [Shall we Start?]. 打招呼并让同事确认别人可以看到我的屏幕 Can you hear me and see my screen? [AA]Yes/No 开始更新，默认情况下，先由我们西安团队更新，再由墨尔本团队更新，我们更新的顺序一般是由Jira 的右边开始，也就是Done 列 Let’s start update from right side? YY, is there any update from you? [YY] Let’s me update ……Ok, That’s it. YY 更新完成后，提示大家继续更新 Next [UU]From my side……Yay, that’s my update. Next 西安团队更新完成后，询问墨尔本团队更新。 Those above update is from xi’an side. Is there any update from Melbourne side? [Melbourne]…… 两个团队更新完成后，需要确认还有什么有更新 Any other update or questions? [silent] If there is no update and question, we will end today’s meeting? Ok, Thanks for joining standup meeting. ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:3:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"结语 作为主持人，我们可以做如下两点： 我们让会议顺利运行下去就可以，用到的英文短语其实也不多，但更重要的是参与者要理解项目运行的各种情况，听懂每个内容更新者说的内容，让主持人作为纽带，使这些内容和参与者联系起来，从而促进工作清晰而高效。 通过与内容更新者沟通，将卡或者项目的进度挖掘出来，这样PM 就不用可以去问了，也可以提高效率。 做为内容更新者， 我们要一边遵循 standup meeting 更新的套路，即昨天干了什么，有什么结果，今天计划要干什么，有什么风险或者需要帮助；另一边我们还要关注其他同事干了什么，某个功能进行到什么程度了，或者某个问题追踪到了什么阶段。每件事都要可执行且结果导向。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:4:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.翻译：https://translate.google.cn/ ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:5:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:6:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["tool"],"content":"场景 在公网上我们获取 npm 包的时候直接就用下面的命令就可以了 $ npm install xxx $ # 或者 # yarn add xxx 但是有时候，公司内部开发的工具库只想放在公司内部的服务器上，那么我们就需要对 npm 源进行配置了。因为 yarn 可以利用缓存，其速度比较快，且 npm 包是公司内部网络，鉴于效率，我们采用 yarn 来提速。 ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:1:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"配置.npmrc 下面是 .npmrc 的通常配置， 这里的 https://npm.xxx.com/npm 就是私服的地址， 下面//开头的内容就是用来鉴权的token。 # .npmrc registry=https://npm.xxx.com/npm //npm.xxx.com/npm/:_authToken=dbef52be-1a83-46e1-a3ce-e0c8727e3fa4 上面的配置，在用 npm 安装私有库或者公有库的时候都没问题，但是我们要使用 yarn，如果再不配置任何内容，在执行 yarn add xxx 的时候，控制台会报如下错误 yarn global v1.22.0 [1/4] 🔍 Resolving packages... error An unexpected error occurred: \"https://npm.xxx.com/npm/yyy: authentication required\". info If you think this is a bug, please open a bug report with the information provided in \"/Users/zhongren.gu/.config/yarn/global/yarn-error.log\". info Visit https://yarnpkg.com/en/docs/cli/global for documentation about this command. 这其实不是 yarn 的 bug, 我们需要在 .npmrc 中增加如下一行 always-auth=true, 最终结果如下 # .npmrc registry=https://npm.xxx.com/npm //npm.xxx.com/npm/:_authToken=dbef52be-1a83-46e1-a3ce-e0c8727e3fa4 always-auth=true ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:2:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"结果 再次执行 yarn add xxx 之后就会正常安装了，以后就可以愉快的安装私服或者公网上的 package 了。 ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:3:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"Reference 1.https://yarnpkg.com/ ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:4:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"使用 Hugo 构建个人博客","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Overview Hugo是一款基于 golang 实现的静态网站生成器。以其简单、易用、高效、易扩展、快速部署受到开发者的喜爱，比起Hexo感觉更轻便。下图是我初步实现的博客截图。 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:1:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"安装 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Golang Hugo 是基于Go语言的，所以需要安装go, 我的机器是Mac, 所以直接用 homebrew 就搞定。 $ brew install go ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:1","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Hugo $ brew install hugo ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:2","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"生成博客站点 $ hugo new site blog ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:3","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"安装 LoveIt 主题 $ cd blog $ git init $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:4","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"配置 config.toml 将themes/LoveIt/exampleSite/config.toml copy 到 blog 根目录，并根据需要修改里面的配置。 注： 需要将 copy 过来的config.toml 里的 themeDir 由../.. 改为 ./themes ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:5","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"优化模板 Hugo 生成的 markdown 文件都是由archetypes/default.md生成的， 所以我们可以在模板里加入一些我们通常使用的文案和图片。 比如： --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: true author: \"谷中仁\" authorLink: \"https://guzhongren.github.io\" description: \"\" license: \"Creative Commons Attribution 4.0 International license\" tags: [\"\"] categories: [\"\"] hiddenFromHomePage: false featuredImage: \"\" featuredImagePreview: \"\" toc: true autoCollapseToc: true math: true comment: true --- ## Reference ---- ![谷哥说-微信公众号](/images/wechat/扫码_搜索联合传播样式-标准色版.png) 生成文章后，直接更新需要更新的字段，如标签（tags）和分类（categories）等，然后在中间直接写文章就可以。 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:3:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"上传到 Github $ git remote add origin git@github.com:guzhongren/guzhongren.github.io.git $ git add . $ git commit -m \"init\" $ git push -u origin master 创建 blog分支 在 Github 上个创建 blog 分支。我们的博客都会在 blog 分支 创建PERSONAL_TOKEN, 或者Deploy Token 我们在Developer settings以 PERSONAL_TOKEN 为例。 然后在项目设置的Secret中用PERSONAL_TOKEN添加 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:3:1","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"自动化部署配置 既然博客基于 github, 那么我们可以直接用 Github Actions, 在项目页点击Actions, 创建一个 Workflow,其内容大致如下 name:githubpageson:push:branches:- blogjobs:build-deploy:runs-on:ubuntu-lateststeps:- uses:actions/checkout@v1# 必须用v1 ，v2 不支持 submodulewith:submodules:true- name:SetupHugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.64.0'- name:Buildrun:hugo--minify- name:addnojekyllrun:touch./public/.nojekyll- name:Deployuses:peaceiris/actions-gh-pages@v3with:# deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}personal_token:${{secrets.PERSONAL_TOKEN}}publish_dir:./publicpublish_branch:masteruser_name:guzhongrenuser_email:guzhongren@live.cn ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:4:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"写文章 为了更好的管理发布的文章，建议用 /year/mouth/article_name.zh.md 这种格式.也可用我写的Makefile命令 $ # hugo new posts/2020/02/first.zh.md $ make post=first.zh.md 然后打开content/posts/2020/02/first.zh.md 进行文章编辑。 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:5:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"预览 在 blog 项目根目录运行如下命令进行预览 $ # hugo server -D $ make pre ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:6:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"提交 提交到 git 中，暂存起来 $ make commit message=feat(post): 发布新文章 或者用如下命令 $ git add -A $ git commit -m feat(post): 发布新文章 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:7:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"发布 将本地更新提交到 github 上， 会自动触发actions 然后进行构建，构建完成后自动将代码部署到 $ make pub 或者用 $ git commit -m \"first article\" $ git pull $ git push ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:8:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"优化 在敲 hugo 相关的命令的时候比较繁琐，有几个参数经常会敲， 所以使用 Makefile 优化一下, 上面有些命令就是在此定义的。 post = default.zh.md message = git commit Year_month = $(shell date +\"%Y/%m\") new: hugo new posts/$(Year_month)/$(post) pre: hugo server -D commit: git add -A git commit -m \"$(message)\" pub: git pull git push new: 创建文章 pre: 写文章时预览 commit: 提交到本地暂存区 pub: 发布文章 尽情享用吧…🎉🎉🎉🎉🎉 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:9:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Reference 1.https://gohugo.io/ 2.https://golang.google.cn/ 3.https://github.com/dillonzq/LoveIt 4.https://github.com/features/actions 5.https://github.com/settings/tokens ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:10:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":null,"content":"About me","date":"2020-02-23","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" 来日方长，慢慢道来… ","date":"2020-02-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["git"],"content":"版本控制策略","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"为了开发高质量的软件，我们需要能够跟踪所有更改并在必要时将其撤消。 版本控制系统通过跟踪项目历史记录并帮助合并多人所做的更改来填补这一角色，极大地加快了工作速度，并使我们能够更轻松地发现错误。 此外，得益于这些工具，分布式团队可以畅通合作,使多个人可以同时处理项目的不同部分，然后将其结果合并为一个产品。 让我们仔细看看版本控制系统，git-flow 和 Trunk-based development(基于主干的开发)是如何形成的。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:0:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"版本控制系统是怎样改变世界的 在版本控制系统出现之前，开发人员依靠手动备份项目的先前版本。他们手工复制修改过的文件，以便将多个开发人员的工作合并到同一项目中。 这样的操作花费了大量时间、硬盘空间和money。 软件的目的是为了更好、更高效的完成工作。工欲善其事必先利其器，那么作为开发者肯定会在产出软件之前对自己的代码进行更有效的管理。 当我们回顾历史时[1]，我们可以大致区分出三代阶段的控制软件。 阶段 操作 并发 存储 工具 1 单文件 锁定文件 集中式 RCS 2 多文件 提交前merge 集中式 Subversion, CVS 3 多文件 merge前提交 分布式 Git, Mercurial 我们注意到随着版本控制系统的成熟，并行处理项目的能力成为了趋势。 最具突破性的更改之一是从锁定文件转变为合并更改。它使开发者能够更有效地工作。 另一个重大改进是引入了分布式系统。 Git是采用这种理念的首批工具之一。 实际上，它使开源世界得以蓬勃发展。 Git允许开发人员通过称为分叉的操作复制整个存储库，并引入所需的更改，而不必担心合并冲突。 随后，开发者可以创建一个PR(Pull request)，以将其更改合并到原始项目中。 如果最初的开发人员对合并其他存储库中的更改不感兴趣，那么他们可以自己将其转换(Fork)为单独的项目。 由于没有中央存储的概念，因此一切皆有可能。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:1:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Git-flow 在 Git-flow 开发模型中，你有一个主分支(master branch)，从主分支创建开发分支(develop branch)，所有开发工作提交都基于开发分支。主分支和开发分支在git-flow 的整个生命周期中都是一直存在的。 开发人员从该开发分支创建功能分支(Feature branch)并对其进行Coding。完成后，它们将创建 PR。在审查(Review) PR过程中，其他开发人员会对更改发表评论，并可能进行讨论，讨论时间也许会很长。 对 PR 评审完成后，PR 将被接受并 merge 到开发分支。 一旦确定开发分支已经成熟到可以发布，就会创建一个单独的分支(release branch)来准备最终版本。 该分支的应用程序已经过测试，并且在准备好将其发布给最终用户之前会应用错误修复(bugfixs)。 完成此操作后，我们会将最终产品合并到主(master branch)分支，并打标签(Tag)。 同时，可以在 develop 分支上继续开发新功能。 Git流的优点之一是严格控制。仔细查看更改后，只有授权的开发人员才能批准更改。它可以确保代码质量，并有助于尽早消除错误。 但是，你需要记住，这也可能是一个巨大的劣势。它会形成一个瓶颈，从而减慢软件开发速度。如果速度是你的首要考虑，那么这应该是一个严重的问题。单独开发的功能可以创建长期存在的分支，这些分支可能很难与主项目结合。 此外，PR 仅将代码重点放在新代码上。他们只查看新引入的更改，而不是整体查看代码并进行改进。在某些情况下，它们可能会导致过早的优化，因为总有可能实现某些功能以使其更快地执行。 还有，PR 可能会导致权利泛滥，在这种情况下，牵头开发人员实际上会管理每行代码。如果你有经验丰富的开发人员可以信任，他们可以处理，但是你可能会浪费他们的时间和技能。它还可能严重削弱开发人员的动力。 在较大的组织中，PR 也可能会导致办公室政治或者以权谋私的事情发生。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:2:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Git-flow 的适用情况分析 git-flow 在什么时候最有效 当你在运营一个开源项目时 这种场景是开源社区，在这里效果最好。 由于每个人都可以做出贡献，因此你希望能够非常严格地访问所有更改。 你希望能够检查每一行代码，坦率地说，你不能相信贡献者。 通常，这些不是商业项目，因此开发速度不是问题。 当你有很多初级开发人员的时候 如果你主要与初级开发人员一起工作，那么你希望有一种方法来仔细检查他们的工作。 你可以为他们提供更多有关如何更有效地 Coding, 并帮助他们更快地提高编程技能。 接受 PR 的人员对重复发生的更改具有严格的控制权，因此可以防止代码质量下降。 当你已经有现成的产品的时候 当你已经有成功的产品时，这种方式也可以很好地发挥作用。 在这种情况下，通常将重点放在应用程序性能和负载功能上。 这种优化需要非常精确的更改。 通常，时间不是限制，因此这种控制在这里效果很好，尤其大型企业非常适合这种风格(因为他们不想破坏自己数百万的投资, 他们需要严密控制每个变更)。 git-flow 会在什么情况下会有问题 当你启动一个新项目时 你可能希望快速创建最小可行的产品(MVP)，提 PR 会产生巨大的瓶颈，这会大大降低整个团队的速度而你负担不起。Git流程的问题在于，PR 可能会花费很多时间。 当你需要快速迭代 达到产品的第一个版本后，你很可能需要几次调整以满足你客户的需求。 同样，多个分支和 PR 会极大地降低开发速度，因此不建议这样做。 当你与高级开发人员一起工作时 如果你的团队主要由相互合作了较长时间的高级开发人员组成，那么你实际上就不需要上述的 PR 。你应该信任你的开发人员，并且知道他们是专业人士，让他们做好自己的工作，不要让所有 Git-Flow的流程拖慢开发进度。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:2:1","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Github-flow Github-flow 是在 git-flow的基础上衍生而来的。他简化了 git-flow 的复杂模型，并且与 Github 可以很好的结合,在此就不赘述了。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:3:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Trunk-based Development(TBD) 在基于主干的开发模型中，所有开发人员都在一个具有开放访问权限的分支上工作。通常它只是master分支。他们将代码提交给它并运行它,非常简单。 在某些情况下，它们会创建短暂的功能分支。 分支上的代码编译并通过所有测试后，便将其直接合并到master。 它可确保开发真正连续进行，并防止开发人员创建难以解决的合并冲突。 用这种方法检查代码的唯一方法是进行完整的源代码检查。 通常，冗长的讨论是有限的。 没有人能严格控制源代码库中正在修改的内容，这就是为什么拥有可强制执行的代码样式很重要的原因。 以这种风格工作的开发人员应具有丰富的经验，以便你知道他们不会降低源代码的质量。 当你与经验丰富的软件开发人员团队一起工作时，这种工作方式可能会很棒。 它使他们能够快速引入新的改进，而无需不必要的官僚作风。 它还显示了你对它们的信任，因为它们可以将代码直接引入master分支。 此工作流程中的开发人员非常自治-他们直接交付并检查工作产品中的最终结果。 这种方法绝对没有办公室管理的微观管理和可能性。 另一方面，如果你没有经验丰富的团队，或者由于某种原因不信任他们，则不应该采用这种方法，而应选择Git flow。它将为你节省不必要的后顾之忧。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:4:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"TBD 的适用情况分析 TBD 的适用情况与git-flow 的适用情况恰好相反，可自行脑补。 我有话说 在我上个项目中,我们的版本控制策略则更激进。 我们所有的开发没有特性分支，所有的 Code 都在 Master 分支上开发，原因有如下： 我们的每张卡都拆的非常细(因为有老 BA) 我们每个人各自负责前端、移动端和后端 最重要的是我们的 CICD 完全一条龙操作，环境有local、DEV、UAT 和 Prod, 在前一个环境QA验证不通过，是进入不到下一个环境的 如果开发速度比较快，有些内容是要在下个版本才要上，那么团队就需要启用FeatureToggle了， 关于这部分可参考之前的《FeatureToggle 引起的….总结》。 软件开发是一场人、语言和工具的故事，但愿你在合适的场景选择合适的工具。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:4:1","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Reference 1.https://rc.sydney.edu.au/git-user-guide/history.html 2.https://nvie.com/files/Git-branching-model.pdf 3.https://trunkbaseddevelopment.com 4.https://guides.github.com/introduction/flow/ ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:5:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["tool"],"content":"将生成的ssh 私钥添加到 Mac 的keychain 中 $ ssh-add -K .ssh/is_rsa ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:1:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"将登录信息配置到.ssh/config中 $ touch ~/.ssh/config $ vim ~/.ssh/config # edit text Host myvm Hostname ip User user ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:2:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"保存之后就可以使用如下命令快捷登录服务器了 $ ssh myvm ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:3:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"参考地址 https://blog.infox.ren/2019/10/24/ssh-guide/ ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:4:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"Reference [1.## 将生成的ssh 私钥添加到 Mac 的keychain 中 $ ssh-add -K .ssh/is_rsa ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:5:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"将登录信息配置到.ssh/config中 $ touch ~/.ssh/config $ vim ~/.ssh/config # edit text Host myvm Hostname ip User user ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:6:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"保存之后就可以使用如下命令快捷登录服务器了 $ ssh myvm ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:7:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"参考地址 1. https://blog.infox.ren/2019/10/24/ssh-guide/ ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:8:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["Web"],"content":"Cargo.toml cargo.toml是Rust 包管理器 cargo 的清单文件。这个文件包 name、 version 和包的依赖，在 Rust 中，我们一般称之为 crate。 在示例中给出了一系列信息，但是我们主要讨论如下三点： crate-type wasm-bindgen 依赖 [features] 和 wee_alloc、console_error_panic_hook 依赖 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:0","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"1.crate-type [lib] crate-type = [\"cdylib\", \"rlib\"] Rust-wasm 包与通常的 crate 有一点不同，作为 WebAssembly 项目， 我们需要在 cargo.toml 中加入该说明。 如果你熟悉其他的 Rust crate，那么你肯定知道，大多的 crate 的类型是 rlib(默认)， 或者是二进制形式的 bin(这种形式不需要 crate-type 注解), 并且 [lib] 注解在普通的 Cargo 项目中并不需要指定。 crate-type = [“cdylib”] 指示你的工程将会被编译为动态系统库 [dynamic system library], 但是对于 WebAssembly，他将会编译为一个没有启动函数的 .wasm 文件，在 Linux 平台上，他将会创建*.so 文件，在macOS 上将会创建*.dylib文件，在 windows 平台上将会创建 *.dylib 文件。 我们通常指定 crate-type = [\"rlib\"] 来确保我们的库可以用 wasm-pack 来做单元测试（稍后会看到）。如果没有这个配置，我们将不能测试我们的库，因为 cdylib 包类型和 wasm-pack 的单元测试类型相冲突。 你可以使用此链接获取更多关于包类型的知识。 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:1","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"2. wasm-bindgen 依赖 wasm-bindgen 在WebAssembly 中是一个重要的依赖。 这个包允许我们使用 [wasm-bindgen] 为在 JavaScript 和 Rust 生成的 wasm 之间的代码打标签。以使我们使用它的属性可以导入 JS 并且导出 Rust。 wasm-bindgen = \"0.2\" 当我们讨论 lib.rs 生成什么内容的时候，将会看到更多关于怎么使用这个库。 如果你从 JavaScript 技术栈过来，你可能注意到了当我们添加依赖的时候并没有加 ^ 或者 ~ ,看起来像是我们只要 0.2 这个版本。然而，事实并非如此！在 Rust 里， ^ 是默认的，你可使用这个 链接查看更多信息 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:2","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"3. [features] 和 wee_alloc, console_error_panic_hook dependencies 作为我们设计模板的工作的一部分，该模板可帮助人们发现针对特定用例的有用包，该模板包括两个依赖项，这对于开发Rust-wasm包的人们可能非常有用：console_error_panic_hook 和 wee_alloc。 因为这些依赖关系主要在 Rust-wasm 包开发工作流程的特定部分中有用，所以我们还设置了一些粘合代码，使我们既可以将它们都包含为依赖关系，又可以选择将它们包含在内。 [features] default = [\"console_error_panic_hook\"] [dependencies] wasm-bindgen = \"0.2\" # The `console_error_panic_hook` crate provides better debugging of panics by # logging them with `console.error`. This is great for development, but requires # all the `std::fmt` and `std::panicking` infrastructure, so isn't great for # code size when deploying. console_error_panic_hook = { version = \"0.1.1\", optional = true } # `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size # compared to the default allocator's ~10K. It is slower than the default # allocator, however. # # Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now. wee_alloc = { version = \"0.4.2\", optional = true } 在我们的代码中，只有在启用某些 [features] 的情况下，我们才会将代码的某些部分标记为正在运行，特别是 console_error_panic_hook 和 wee_alloc。默认情况下，仅启用 console_error_panic_hook。要禁用或启用任一功能，默认情况下，我们可以在 [features] 下编辑 default 数组。 要了解有关这些功能的更多信息，我们将在 src/lib.rs 和 src/utils.rs 部分中深入讨论它们。 简要地，它们包括： console_error_panic_hook ，用于将奔溃消息记录到开发人员控制台的功能。 wee_alloc，一个使代码量更小而优化的分配器。 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:3","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"Reference 1.https://guzhongren.github.io/ ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:2:0","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"基于Rust的WebAssembly工程开发过程小记","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"初始化工程 $ npm init rust-webpack web_assembly_demo npx: 18 安装成功，用时 3.989 秒 Rust + WebAssembly + Webpack = ️ Installed dependencies ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:1:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"安装 Web 依赖 $ yarn yarn install v1.19.1 warning package.json: No license field info No lockfile found. warning package-lock.json found. Your project contains lock files generated by tools other than Yarn. It is advised not to mix package managers in order to avoid resolution inconsistencies caused by unsynchronized lock files. To clear this warning, remove package-lock.json. warning rust-webpack-template@0.1.0: No license field [1/4] Resolving packages... warning @wasm-tool/wasm-pack-plugin \u003e watchpack \u003e chokidar \u003e fsevents@1.2.9: One of your dependencies needs to upgrade to fsevents v2: 1) Proper nodejs v10+ support 2) No more fetching binaries from AWS, smaller package size [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. Done in 17.87s. ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:2:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"修改 Cargo.toml 为 # You must change these to your own details. [package] name = \"web_assembly_demo\" description = \"My super awesome Rust, WebAssembly, and Webpack project!\" version = \"0.1.0\" authors = [\"guzhongren \u003cguzhoongren@live.cn\u003e\"] categories = [\"wasm\"] readme = \"README.md\" edition = \"2018\" [lib] crate-type = [\"cdylib\"] [profile.release] # This makes the compiled code faster and smaller, but it makes compiling slower, # so it's only enabled in release mode. lto = true [features] # If you uncomment this line, it will enable `wee_alloc`: #default = [\"wee_alloc\"] [dependencies] # The `wasm-bindgen` crate provides the bare minimum functionality needed # to interact with JavaScript. wasm-bindgen = \"0.2.45\" # `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size # compared to the default allocator's ~10K. However, it is slower than the default # allocator, so it's not enabled by default. wee_alloc = { version = \"0.4.2\", optional = true } # The `web-sys` crate allows you to interact with the various browser APIs, # like the DOM. [dependencies.web-sys] version = \"0.3.22\" features = [\"console\"] # The `console_error_panic_hook` crate provides better debugging of panics by # logging them with `console.error`. This is great for development, but requires # all the `std::fmt` and `std::panicking` infrastructure, so it's only enabled # in debug mode. [target.\"cfg(debug_assertions)\".dependencies] console_error_panic_hook = \"0.1.5\" # These crates are used for running unit tests. [dev-dependencies] wasm-bindgen-test = \"0.2.45\" futures = \"0.1.27\" js-sys = \"0.3.22\" wasm-bindgen-futures = \"0.3.22\" Rust 的依赖会在启动 Web 程序的时候自动安装。 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:3:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"启动程序 $ yarn start yarn run v1.19.1 warning package.json: No license field $ rimraf dist pkg \u0026\u0026 webpack-dev-server --open -d 🧐 Checking for wasm-pack... wasm-pack is installed. ℹ️ Compiling your crate in development mode... ℹ ｢wds｣: Project is running at http://localhost:8080/ ℹ ｢wds｣: webpack output is served from / ℹ ｢wds｣: Content not from webpack is served from /Users/c4/Desktop/Personal/01.Project/web_assembly/web_assembly_demo/dist [INFO]: Checking for the Wasm target... [INFO]: Compiling to Wasm... ℹ ｢wdm｣: wait until bundle finished: / Compiling proc-macro2 v1.0.6 Compiling unicode-xid v0.2.0 ... 3 assets Entrypoint index = index.js [./pkg/index.js] 4.41 KiB {0} [built] [./pkg/index_bg.wasm] 145 KiB {0} [built] + 33 hidden modules ℹ ｢wdm｣: Compiled successfully. ℹ️ Compiling your crate in development mode... [INFO]: Checking for the Wasm target... [INFO]: Compiling to Wasm... Compiling rust-webpack-template v0.1.0 (/Users/c4/Desktop/Personal/01.Project/web_assembly/web_assembly_demo) Finished dev [unoptimized + debuginfo] target(s) in 0.62s [INFO]: ⬇️ Installing wasm-bindgen... [INFO]: Optional fields missing from Cargo.toml: 'repository', 'license'. These are not necessary, but recommended [INFO]: Done in 0.77s [INFO]: Your wasm pkg is ready to publish at ./pkg. Your crate has been correctly compiled ℹ ｢wdm｣: Compiling... ℹ ｢wdm｣: Hash: d4e8a3c57ad23f847707 Version: webpack 4.41.2 Time: 411ms Built at: 2019-11-23 20:16:55 Asset Size Chunks Chunk Names 0.js 17 KiB 0 [emitted] beee557fb69dcfa0df60.module.wasm 161 KiB 0 [emitted] [immutable] index.js 897 KiB index [emitted] index Entrypoint index = index.js [./pkg/index.js] 4.93 KiB {0} [built] [./pkg/index_bg.wasm] 161 KiB {0} [built] + 33 hidden modules ℹ ｢wdm｣: Compiled successfully. ℹ ｢wdm｣: Compiling... ℹ ｢wdm｣: Hash: 3e1681b9b4c4c940722e Version: webpack 4.41.2 Time: 16ms Built at: 2019-11-23 20:17:14 Asset Size Chunks Chunk Names index.js 897 KiB index [emitted] index + 2 hidden assets ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:4:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在src中新建parse.rs 并编写处理 markdown 的 rust 代码 struct Parser{pos: usize,input: String,}pubfn parse(source: String)-\u003e String {Parser{pos: 0,input: source,}.parse_lines()}implParser{fn parse_lines(\u0026mutself)-\u003e String {letmutresult=String::new();loop{self.consume_whitespace();ifself.end_of_line(){break;}result.push_str(\u0026self.parse_line());}result}fn parse_line(\u0026mutself)-\u003e String {matchself.next_char(){'#'=\u003eself.parse_title(),'-'=\u003e{ifchar::is_whitespace(self.input[self.pos+1..].chars().next().unwrap()){self.parse_list()}else{self.parse_text()}}_=\u003eself.parse_text(),}}fn parse_list(\u0026mutself)-\u003e String {self.consume_char();self.consume_whitespace();lettext=self.parse_text();create_html_element(\"li\".to_string(),text)}fn parse_title(\u0026mutself)-\u003e String {letpound=self.consume_while(|c|c=='#');self.consume_whitespace();lettext=self.parse_text();create_html_element(format!(\"h{}\",pound.len()),text)}fn parse_text(\u0026mutself)-\u003e String {self.consume_while(|c|!is_new_line(c))}fn end_of_line(\u0026self)-\u003e bool {self.pos\u003e=self.input.len()}// fn starts_with(\u0026self, s: \u0026str) -\u003e bool { // self.input[self.pos..].starts_with(s) // } fn next_char(\u0026self)-\u003e char{self.input[self.pos..].chars().next().unwrap()}fn consume_char(\u0026mutself)-\u003e char{letmutiter=self.input[self.pos..].char_indices();let(_,cur_char)=iter.next().unwrap();let(next_pos,_)=iter.next().unwrap_or((1,' '));self.pos+=next_pos;cur_char}fn consume_while\u003cF\u003e(\u0026mutself,cond: F)-\u003e String whereF: Fn(char)-\u003e bool,{letmutresult=String::new();while!self.end_of_line()\u0026\u0026cond(self.next_char()){result.push(self.consume_char());}result}fn consume_whitespace(\u0026mutself){self.consume_while(char::is_whitespace);}}fn create_html_element(tag_name: String,text: String)-\u003e String {format!(\"\u003c{}\u003e{}\u003c/{}\u003e\",tag_name,text,tag_name)}fn is_new_line(c: char)-\u003e bool {c=='\\n'} ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:5:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在 src/lib.rs 中引入 parse mod， 并编写向外暴露的函数 mod parser;externcratewasm_bindgen;usewasm_bindgen::prelude::*;#[wasm_bindgen]pubfn parse(input: \u0026str)-\u003e String {letresult=parser::parse(input.to_string());result} ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:6:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在 js/index.js 中使用 Web Assembly ，修改结果如下 document.body.onload=addElement;functionaddElement(){constmarkdown=document.createElement('textarea')markdown.id='markdown'markdown.style=\"height: 300px; width: 400px ;\"document.body.appendChild(markdown)constparseBtn=document.createElement('button')parseBtn.id='parse'parseBtn.innerHTML='解析markdown'document.body.appendChild(parseBtn)constpreviewArea=document.createElement('div')previewArea.id='preview'document.body.appendChild(previewArea)construst=import('../pkg/index.js')rust.then(module=\u003e{constbtn=document.getElementById('parse')constpreviewArea=document.getElementById('preview')btn.addEventListener('click',()=\u003e{constinput=document.getElementById('markdown').valuepreviewArea.innerHTML=module.parse(input)})})}// import(\"../pkg/index.js\").then(module =\u003e { // const input = '1233' // previewArea.innerHTML = module.parse(input) // }).catch(console.error); ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:7:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"效果图 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:8:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在线体验 Markdown editor: https://andorlab.github.io/WebAssembly/ ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:9:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"后续 后面会在这个基础上继续开发，并将 WASM 中的一些概念配置也写成文档共享在博客中。 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:10:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"仓库地址：https://github.com/AndorLab/web_assembly/tree/based_rust ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:11:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:12:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:13:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于Rust的WebAssembly工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["tool"],"content":"插件 在 VS Code 上进行 Rust 的开发，需要使用一下两个库 RLS(vscode搜索插件rls) lldb(vscode搜索插件codelldb) 安装很简单，不用说 ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:1:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置Rust的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["tool"],"content":"配置 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug executable 'show_posts'\", // 配置名称，将会在调试配置下拉列表中显示 \"type\": \"lldb\", // 调试器类型：Windows表示器使用cppvsdbg；GDB和LLDB使用cppdbg。该值自动生成 \"request\": \"launch\", // 调试方式 \"cargo\": { // 运行的参数 \"args\": [ \"build\", \"--bin=show_posts\", \"--package=diesel_demo\" ], \"filter\": { \"name\": \"show_posts\", \"kind\": \"bin\" } }, \"args\": [], // 传递给程序的参数，没有参数留空即可 \"cwd\": \"${workspaceFolder}\" // 调试程序时的工作目录 }, } ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:2:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置Rust的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["tool"],"content":"调试 ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:3:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置Rust的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["tool"],"content":"Reference 1.https://guzhongren.github.io/ ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:4:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置Rust的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["Code"],"content":"情景 在我们开发中，我们通常需要对某一系列的组件Coding, 但我们是程序员啊，我们怎么能容忍代码重复出现的坏味道呢。所以，对于一些列相同的操作我们就要用到循环处理了。 ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:1:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的Value上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"目标 我们需要将底部两个按钮 新建询价和 采购助手展示出来，并且点击他们的操作后有不同的交互。 ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:2:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的Value上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"coding 对于此情况，我们需要将对两个按钮做抽象，抽象为数组，在render函数里循环执行即可，这里有个地方需要说明一下，我们把事件处理函数也放在了抽象好的对象上，如下 const tools = [ { index: 1, image: images.tabs.newEnquiryTool, title: '新建询价', onPress: () =\u003e { this.props.controlToolVisible(false) Actions.newEnquiry() }, }, { index: 2, image: images.tabs.purchaseAsstant, title: '采购助手', onPress: () =\u003e { Chatlogin().then(data =\u003e { if (data) { this.props.getAccountInfo(_.get(global.USER_INFO, 'imInfo.mpcAccId')) .then(chatInfo =\u003e { this.props.controlToolVisible(false) Actions.chat({ session: { contactId: 123, name: '31231', sessionType: '0' } }) }) .catch(console.error) } }) }, }, ] 在render函数里我们循环即可实现代码的抽象 { tools.map((tool) =\u003e ( \u003cTouchableOpacity style={styles.toolWrapper} key={tool.index} onPress={tool.onPress} \u003e \u003cImage source={tool.image} /\u003e \u003cText style={styles.text}\u003e{tool.title}\u003c/Text\u003e \u003c/TouchableOpacity\u003e)) } ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:3:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的Value上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"总结 代码总是可以解决很多问题，在Coding 时，应该及时重构，将代码中的坏味道及时剔除，为以后业务功能开发解决技术债。 ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:4:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的Value上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"Reference 1.https://guzhongren.github.io/ ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:5:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的Value上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["git","revert","multRevert"],"content":"我需要撤销最后的四个提交 如果用git revert * 一个一个revert 挺费劲，可以用git revert OLDER_COMMIT^..NEWER_COMMIT* 这种格式，对应我的工程就是 $ git revert 54b23c2251acde.....09123463e99436fba83f9^..a19a10b24b648b80401234686aac65... 这样会在log 上多留下四条revert相关的记录，我不想生成revert相关的记录呢？可以的 $ git revert -n 54b23c2251acde.....09123463e99436fba83f9^..a19a10b24b648b80401234686aac65... 就是多加个 -n 参数，然后再通过 git add 和git commit 等步骤就可以了。 最后的效果如下 ","date":"2019-09-30","objectID":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/:0:0","tags":["git"],"title":"Git Revert 多条已提交的记录","uri":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/"},{"categories":["git","revert","multRevert"],"content":"Reference 1.https://guzhongren.github.io/ ","date":"2019-09-30","objectID":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["git"],"title":"Git Revert 多条已提交的记录","uri":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"场景 在平时开发中我们有自己的git仓库，组内提交都是在这个库。突然有一天，领导说要把这个库整合到另一个更大的工程中（华为云的看板），那里面有前后端的代码；为了方便大家查找，我们需要将各个组的代码迁移到同一个大工程下。 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用git迁移git项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"问题 提交要保留提交记录 changelog要保留 组内成员要保留 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用git迁移git项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"解决方案 git push --mirror ...... ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用git迁移git项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"操作 假如我们原有的仓库为git@codehub.devcloud.huaweicloud.com:project.git 1. 从原地址克隆一份裸版本库 $ git clone --bare git@codehub.devcloud.huaweicloud.com:project.git ...... 2. 在新目录创建git空项目 这一步是为了让旧项目有镜像 假如新仓库地址为git@codehub.devcloud.huaweicloud.com:leaderProject.git 3. 镜像推送代码到新仓库 进入旧git目录，推送即可 $ cd project $ git push --mirror git@codehub.devcloud.huaweicloud.com:leaderProject.git ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:4:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用git迁移git项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"晒个图 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:5:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用git迁移git项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.原文：https://yq.aliyun.com/articles/675073?spm=a2c4e.11155435.0.0.27543312iFnJbY ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:6:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用git迁移git项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:7:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用git迁移git项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Dependency Injection 🧪 依赖注入是目前很多优秀框架都在使用的一个设计模式。 Dependency Injection 常常简称为：DI。它是实现控制反转（Inversion of Control – IoC）的一个模式。 在各种大工程中少不了各种测试，其中 TDD 就是非常流行的一种，在前端开发中用的比较多的 Jest 就是一种，在 Golang 开发命令行工具的时候也是需要 DI 这种模式来实现命令行测试的。因为传统的测试室获取不到命令行的输入输出的。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:0:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"工程意图 仓库：https://github.com/guzhongren/TDD/tree/master/10.dependency-injection 编写一个命令行工具库，打包并运行程序，根据工具名称后面的名称来显示 'Hello, + 名称'。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:1:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"简化程序 我们知道 golang 打包后就是一个可执行程序，程序名称根据你指定的名称显示，那么要实现这个工具就是需要接收到程序名后面的参数并显示出来。但本次的重点是实现 DI, 所以我们将重点放在命令行的测试与实现上。 我们只实现 Greet 函数的 DI 就可以了。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:2:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"初始化工程 go mod init dependency-injection 按照惯例，测试的函数需要以 Test 开头，参数为 *testing.T 类型 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:3:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"Test 测试先行 func TestGreet(t *testing.T) { // 申明 buffer，准备接受数据， 因为bytes.Buffer， 重点：bytes.Buffer实现了 io.Writer buffer := bytes.Buffer{} // 将buffer 传入，此时就是依赖注入的入口， Greet(\u0026buffer, \"chris\") // 获取程序运行的结果 got := buffer.String() // 期望值 want := \"Hello, chris\" // 测试判断 if got != want { t.Errorf(`got %s, want %s`, got, want) } } 运行 go test, 程序会报错，因为没有实现 Greet 函数。 最小化的实现 Repeat // Greet 打印问候 func Greet(w io.Writer, name string) { fmt.Fprintf(w, \"Hello, \"+name) } 重点说明，命令行的测试需要将结果打印在命令行窗口中，如果没有测试，我们可以用 fmt.Printf 等打印函数将结果打印出来，但是， 测试需要拿到打印的内容，就需要将内容用标准输出；当然可以变相的先用其他打印函数将结果打印出来，然后再将结果 return 出去， 在测试中，接受返回值，再比较；这样做不标准而已，学了今天内容其实就可以用 DI 来解决了。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:4:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"运行测试 基本测试 $ go test PASS ok dependency-injection 0.006s ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:5:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"总结 基本测试很简单，不用解读了。作为开发者，我们应该用最直接的工具来保证我们程序的健壮性，而不一定要绕个弯来解决问题，如上面的打印结果的测试。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:6:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"Reference 1.https://golang.google.cn/ ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:7:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入(Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"Benchmark 🧪 基准测试是对计算机系统的性能的测试。 在程序中，基准测试，是一种测试代码性能的方法；比如有一个问题你有多种不同的方案，你想选择一种性能最好的方案，那么你就需要基准测试。 基准测试主要是通过测试 CPU 和内存的效率问题，来评估被测试代码的性能，进而找到更好的解决方案。比如链接池的数量不是越多越好，那么哪个值才是最优值呢，这就需要配合基准测试不断调优了。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:0:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"工程意图 仓库： https://github.com/guzhongren/TDD/tree/master/09.benchmar 根据输入的字符串和重复次数，输出重复次数后的字符串。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:1:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"初始化工程 go mod init benchmark 测试的函数需要以 Test 开头，参数为 *testing.T 类型 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:2:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"Test 测试先行 # 测试 Repeat 函数 func TestRepeat(t *testing.T) { actual := Repeat(`a`, 6) expect := `aaaaaa` if actual != expect { t.Errorf(`expect %s, but got %s`, expect, actual) } } 运行 go test, 程序会报错，因为没有实现 Repeat 函数。 最小化的实现 Repeat // Repeat return a string with same char func Repeat(char string, count int) (result string) { for i := 0; i \u003c count; i++ { result += char } return } 上面的函数中 return 并没有返回值，是因为，在 Repeat 函数的返回值部分有一个result， 当返回值是函数体里面的值的时候，可以不用写返回值，go 程序自动将该值返回。但return 依旧不能省略。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:3:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"Benchmark 基准测试的函数名须以 Benchmark 开头， 参数须为 *testing.B；循环中的 b.N， go 会根据系统情况生成，不用用户设定。 func BenchmarkRepeat(b *testing.B) { for i := 0; i \u003c b.N; i++ { Repeat(`b`, 5) } } ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:4:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"运行测试 基本测试 $ go test PASS ok benchmark 0.006s 基本测试很简单，不用解读了。 基准测试 $ go test -bench=. -run=none goos: darwin goarch: amd64 pkg: benchmark BenchmarkRepeat-12 10000000 116 ns/op PASS ok benchmark 1.297s 运行基准测试也要使用go test命令，不过我们要加上-bench=标记，它接受一个表达式作为参数，匹配基准测试的函数，. 表示运行所有基准测试。 因为默认情况下 go test 会运行单元测试，为了防止单元测试的输出影响我们查看基准测试的结果，可以使用-run=匹配一个从来没有的单元测试方法，过滤掉单元测试的输出，我们这里使用none，因为我们基本上不会创建这个名字的单元测试方法。 下面着重解释下说出的结果，看到函数后面的-12了吗？这个表示运行时对应的 GOMAXPROCS 的值。接着的 10000000 表示运行 for 循环的次数，也就是调用被测试代码的次数，最后的 116 ns/op表示每次需要话费 116 纳秒。 以上是测试时间默认是1秒，也就是1秒的时间，调用 10000000 次，每次调用花费 116 纳秒。如果想让测试运行的时间更长，可以通过 -lunchtime 指定，比如5秒。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:5:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"Reference ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:6:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"1.https://golang.google.cn/ 2.Golang 依赖注入(Dependency Injection) ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:7:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试(Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":" 简介 目标 目的 Coding 目录结构 封装 error 函数 安装 SQLLite 库及其他库 申明 DB 全局变量 初始化数据库 用户模型构建及原子操作 用户模型 新增 删除 修改 查询 在应用中启动并调用用户模型的方法 运行结果展示 总结 Reference Hereby declared（特此申明） ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:0:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"简介 SQLite 是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，你不需要在系统中配置。在 Golang 中使用SQLLite 也相当简单，只需要安装 SQLLite 的Golang 包即可使用； Golang 就不多介绍了，能看到这个肯定对 Golang 有一定的了解。 仓库地址：https://github.com/AndorLab/golang-sqllite ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:1:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"目标 使用 SQLLite 通过构建一个社区用户表，包含如下字段; 通过 SQLLite 的 API 实现对社区用户表进行增删改查。 序号 字段 类型 说明 1 uid int64 id 2 username string 用户名 3 city string 城市 4 skills string 技能 5 created int64 创建时间 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:2:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"目的 了解 SQLLite ，学习 Golang 操作 SQLLite, 巩固 Golang 基础知识。 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:3:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"Coding ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"目录结构 项目采用 Golang 传统的平铺式目录 . ├── LICENSE ├── Makefile # 构建工具 ├── README.md # README ├── db.go # 数据库操作 ├── error.go # 错误处理工具方法 ├── fcc.db # sqllite 数据库 ├── go.mod # go modules ├── go.sum # go modules ├── main.go # 项目入口 ├── server.go # 应用程序入口 └── userModel.go # 用户模型 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:1","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"封装 error 函数 因为在 go 中会有很多的 error 的判断，为了代码精简，我们特封装一下 error; 下面的 interface{} 代表任何类型，类似 TypeScript 中的 any。 # error.go func checkErr(data interface{}, err error) (interface{}, error) { if err != nil { log.Error(err) return nil, err } return data, err } ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:2","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"安装 SQLLite 库及其他库 使用 go modules 之后，将所需的包放在 import 中，使用 go mod tidy 命令后，go 会自动安装程序使用到的包。 日志相关的库，主要用于在控制台打印结果 # server.go import ( \"github.com/labstack/gommon/log\" ) SQLLite 包 # db.go _ \"github.com/mattn/go-sqlite3\" ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:3","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"申明 DB 全局变量 因为在程序中，我们要通过数据库来获取数据，那么存在一个全局的数据库指针是很有必要的。 # main.go var db = new(sql.DB) ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:4","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"初始化数据库 SQLLite 初始化数据库非常简单，只要指定数据库驱动和数据库文件就可以。为了在程序的整个生命周期中操作数据库，我们将 db 返回。 // openDB 打开数据库 func openDB() *sql.DB { //打开数据库，如果不存在，则创建 db, err := sql.Open(\"sqlite3\", \"./fcc.db\") checkErr(db, err) return db } 创建好 db 后，需要创建表结构，执行如下数据库操作命令即可完成用户表的创建。 // initDB 初始化数据库 func initDB() { //创建表 sqlTable := `CREATE TABLE IF NOT EXISTS userinfo( uid INTEGER PRIMARY KEY AUTOINCREMENT, username VARCHAR(64) NULL, city VARCHAR(64) NULL, skills VARCHAR(128) NULL, created BIGINT NULL ); ` db.Exec(sqlTable) } ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:5","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"用户模型构建及原子操作 构建现代程序，强调程序的健壮性，封装就是比较重要的；用 MVC、 MVVM 的观点，我们需要有一个 Model 来提供对象的原子操作。在这，我们将用户抽象为UserModel，对用户的增删改查封装到 insert、dleete、update 和 query。 用户模型 // UserModel 用户模型 type UserModel struct { uid int64 username string city string skills string created int64 } 对用户的原子操作 新增 // insert 新增 func (u UserModel) insert() (sql.Result, error) { stmt, err := db.Prepare(\"insert into userinfo(username, city, skills, created) values(?,?,?,?)\") checkErr(stmt, err) res, err := stmt.Exec(u.username, u.city, u.skills, time.Now().Unix()) checkErr(res, err) return res, nil } 删除 // delete 删除 func (u UserModel) delete(id int64) int64 { stmt, err := db.Prepare(\"delete from userinfo where uid=?\") checkErr(stmt, err) res, err := stmt.Exec(id) checkErr(res, err) affect, err := res.RowsAffected() checkErr(affect, err) return affect } 修改 // update 更新用户技能 func (u UserModel) update(id int) int64 { stmt, err := db.Prepare(\"update userinfo set skills=? where uid=?\") checkErr(stmt, err) res, err := stmt.Exec(u.skills, id) checkErr(res, err) affect, err := res.RowsAffected() checkErr(affect, err) return affect } 查询 // query 查询 func (u UserModel) query() ([]UserModel, error) { rows, err := db.Query(\"select * from userinfo\") checkErr(rows, err) var userList = []UserModel{} for rows.Next() { var user = UserModel{} err = rows.Scan(\u0026user.uid, \u0026user.username, \u0026user.city, \u0026user.skills, \u0026user.created) checkErr(nil, err) userList = append(userList, user) } rows.Close() return userList, nil } ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:6","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"在应用中启动并调用用户模型的方法 在上面我们完成了对用户模型及原子操作的封装，那么接下来就是通过应用程序将分装的内容调用，传入正确的参数进行调用。 我们在此封装一个 startAPP 方法，在这个里面我们调用封装好的用户操作的接口，实现功能。 因为数据库要在整个生命周期存在，当程序结束的时候，我们应该将数据库链接释放，所以我们用到了 go 的 defer 关键字 # server.go db = openDB() defer db.Close() initDB() 调用用户操作的增删改查并打印结果, 对于不同的操作，我们应该有不同的数据，所以在程序中会有 user、和 updateUser 两个对象 # server.go user := UserModel{ username: \"谷中仁\", city: `西安`, skills: `TypeScript`, } // insert result, err := user.insert() id, err := result.LastInsertId() checkErr(id, err) log.Info(\"增：操作数据的id:\", id) // update updateUser := UserModel{ skills: `golang`, } affectedRow := updateUser.updateSkills(1) log.Info(\"改：影响的行数：\", affectedRow) // query queryUser := UserModel{} list, _ := queryUser.query() log.Info(\"查：\", list) // delete affect := queryUser.delete(1) log.Info(\"删：\", affect) // query list, _ = queryUser.query() log.Info(\"查：\", list) ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:7","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"运行结果展示 $ make run go run *.go {\"time\":\"2019-08-31T14:21:48.941164+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"21\",\"message\":\"增：操作数据的id:1\"} {\"time\":\"2019-08-31T14:21:48.941842+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"27\",\"message\":\"改：影响的行数：1\"} {\"time\":\"2019-08-31T14:21:48.942034+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"31\",\"message\":\"查：[{1 谷中仁 西安 golang 1567232508}]\"} {\"time\":\"2019-08-31T14:21:48.942599+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"34\",\"message\":\"删：1\"} {\"time\":\"2019-08-31T14:21:48.942696+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"38\",\"message\":\"查：[]\"} ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:8","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"总结 SQLLite 对开发者非常友好，不用安装在机器上，只要指定SQLLite的驱动和数据库存储文件即可对 SQLLite 数据库进行操作；Golang 作为比较流行的语言，对数据库也非常友好，提供了基本的数据库接口， 至于用户需要什么样的数据库，自己开发对应的数据库驱动即可。当然在 GitHub 已经有很多开源爱好者开发了比较流行的数据库的驱动可以直接拿来用。 SQLLite 使用的也是标准的 SQL 语法，可以让不同的开发者快速入手。 为什么没有用到 Golang 的 Web 框架？ 因为我们的侧重点在 Golang 与 SQLLite，不在 API 实现上，最小化的实现目标，才是我们学习知识最快速的途径。 原文链接：https://chinese.freecodecamp.org/news/golang-with-sqllite-practice/ ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:5:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"Reference 1.博客：https://guzhongren.github.io/* 2.原文：https://yq.aliyun.com/articles/716696?spm=a2c4e.11155435.0.0.5d7c3312dFgns3 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:6:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:7:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["基础知识"],"content":"这是一篇用于预览 Markdown 基本语法的文章。","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"这是一篇用于预览  Markdown 基本语法的文章。 文章内容基于 GitHub Flavored Markdown Spec。 不包含复杂的规则说明，仅仅展示 GFM 所约定的 Markdown 基本语法。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:0:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"1 引言  Markdown 是一种用于编写结构化文档的纯文本格式。它基于电子邮件和论坛文章的格式所约定。 它由 John Gruber (在 Aaron Swartz 的帮助下)开发，于 2004 年以语法描述和用于将 Markdown 转换为 HTML 的 Perl 脚本 (Markdown.pl) 的形式发布。 在接下来的十年中，许多实现被开发出来。一些用脚注、表和其他文档元素的约定扩展了原始 Markdown 语法。 有些允许 Markdown 文档以 HTML 以外的格式呈现。 像 reddit，StackOverflow 和 GitHub 这样的网站有上百万的用户在使用 Markdown。 Markdown 开始被应用于网络以外的领域，包括作者书籍、文章、幻灯片、信件和课堂笔记。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:1:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"2 块和内联元素 我们可以把一个文档看成一系列的块，如段落、引用、列表、标题和代码块。 有些块(如引号和列表)可以包含其它的块，即 容器块； 其他的块(如标题和段落)则包含内联元素(如文本、链接、强调、图像、内联代码等)，即 叶子块。 块的符号总是优先于内联元素的符号。例如： - `one - two` `one two` ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:2:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3 叶子块 本节描述用于组成 Markdown 文档的不同类型的叶子块。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:3:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.1 换行符 *** ------ ____ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:3:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.2 标题 关于 ATX 风格标题和 Setext 风格标题 本文只展示 ATX 风格标题，关于 Setext 风格标题的介绍请参考 GFM Setext headings 说明。 笔者不推荐在 Hugo 的 Markdown 文档中使用 Setext 风格标题。 ## H2 二级标题 ### H3 三级标题 #### H4 四级标题 ##### H5 五级标题 ###### H6 六级标题 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:3:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"H2 二级标题 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"H3 三级标题 H4 四级标题 H5 五级标题 H6 六级标题 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.3 代码块 关于缩进式代码块和围栏式代码块 本文只展示围栏式代码块，关于缩进式代码块的介绍请参考 GFM Indented code blocks 说明。 笔者不推荐在 Hugo 的 Markdown 文档中使用缩进式代码块。 ``` foo() ``` ~~~ foo() ~~~ ```` foo() ```` ```rubydef foo(x) return 3 end ``` foo() foo() foo() def foo(x) return 3 end package main import \"fmt\" func main() { fmt.Println(\"Hello, 世界\") } ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.4 段落 这是一个段落。 这还是之前段落的一部分。 这是新的段落。 这是一个段落。 这还是之前段落的一部分。 这是新的段落。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:3","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.5 引用链接的定义 [foo]: / \"title\" [foo] [bar]: / [bar] foo bar ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:4","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.6 空白行 块之间的空白行将被忽略，除了它们在确定列表是紧还是松时所起的作用。 文档开头和结尾的空行也会被忽略。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:5","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4 容器块 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.1 引用 \u003e Foo \u003e \u003e - **bar** \u003e - baz Foo bar baz ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.2 无序列表 - 项目 1 * 项目 A - 项目 B 一些说明 + 项目 a * 项目 b - 项目 c + 项目 C + 项目 2 * 项目 3 项目 1 项目 A 项目 B 一些说明 项目 a 项目 b 项目 c 项目 C 项目 2 项目 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.3 有序列表 1. 项目 1 1. 项目 A 2. 项目 B 一些说明 1. 项目 a 2. 项目 b 3. 项目 c 3. 项目 C 2. 项目 2 3. 项目 3 项目 1 项目 A 项目 B 一些说明 项目 a 项目 b 项目 c 项目 C 项目 2 项目 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:3","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.4 任务列表 - [ ] 任务 1 * [X] 任务 A - 任务 B + [ ] 任务 a * [ ] 任务 b - [X] 任务 c + [X] 任务 C + [ ] 任务 2 * [X] 任务 3 任务 1 任务 A 任务 B 任务 a 任务 b 任务 c 任务 C 任务 2 任务 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:4","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.5 表格 | _颜色_ | 水果 | 蔬菜 | | ---------- |:---------------:| -----------:| | 红色 | *苹果* | 辣椒 | | ~~橙色~~ | 橘子 | **胡萝卜** | | 绿色 | ~~***梨子***~~ | 菠菜 | 颜色 水果 蔬菜 红色 苹果 辣椒 橙色 橘子 胡萝卜 绿色 梨子 菠菜 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:5","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3. 页内锚 [脚注](#footnote) ## 4. 脚注 {#footnote} 脚注 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:6:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4. 脚注 这是一个基本的数字脚注[^1] 带有 \"label\" 标签的脚注[^label] 下定义的脚注[^!DEF] 带有链接的脚注[^pa] [^1]: 这是一个基本的数字脚注 [^label]: 带有 \"label\" 标签的脚注 [^pa]: [LoveIt 主题](https://github.com/dillonzq/LoveIt) [^!DEF]: 下定义的脚注 这是一个基本的数字脚注1 带有 “label” 标签的脚注2 下定义的脚注3 带有链接的脚注4 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:7:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"5. 内联格式 `内联代码块` \u003ckbd\u003ectrl\u003c/kbd\u003e+\u003ckbd\u003ealt\u003c/kbd\u003e+\u003ckbd\u003edel\u003c/kbd\u003e **加粗 1** 和 __加粗 2__ *倾斜 1* 和 _倾斜 2_ ~~删除线~~ ***加粗 1 和 倾斜 1*** ___加粗 2 和 倾斜 2___ __*加粗 2 和 倾斜 1*__ **_加粗 1 和 倾斜 2_** ~~*删除线 倾斜 1*~~ 和 *~~删除线 倾斜 2~~* ~~_删除线 倾斜 2_~~ 和 _~~删除线 倾斜 2~~_ ~~**删除线 加粗 1**~~ 和 **~~删除线 加粗 1~~** ~~__删除线 加粗 2__~~ 和 __~~删除线 加粗 2~~__ ~~***删除线 倾斜 1 加粗 1***~~ 和 ***~~删除线 倾斜 1 加粗 1~~*** ~~___删除线 倾斜 2 加粗 2___~~ 和 ___~~删除线 倾斜 2 加粗 2~~___ **~~*删除线 倾斜 1 加粗 1*~~** 和 *~~**删除线 倾斜 1 加粗 1**~~* __~~_删除线 倾斜 2 加粗 2_~~__ 和 _~~__删除线 倾斜 2 加粗 2__~~_ **~~_删除线 倾斜 2 加粗 1_~~** 和 _~~**删除线 倾斜 2 加粗 1**~~_ __~~*删除线 倾斜 1 加粗 2*~~__ 和 *~~__删除线 倾斜 1 加粗 2__~~* 内联代码块 ctrl+alt+del 加粗 1 和 加粗 2 倾斜 1 和 倾斜 2 删除线 加粗 1 和 倾斜 1 加粗 2 和 倾斜 2 加粗 2 和 倾斜 1 加粗 1 和 倾斜 2 删除线 倾斜 1 和 删除线 倾斜 2 _删除线 倾斜 2_ 和 删除线 倾斜 2 删除线 加粗 1 和 删除线 加粗 1 __删除线 加粗 2__ 和 删除线 加粗 2 删除线 倾斜 1 加粗 1 和 删除线 倾斜 1 加粗 1 ___删除线 倾斜 2 加粗 2___ 和 删除线 倾斜 2 加粗 2 删除线 倾斜 1 加粗 1 和 删除线 倾斜 1 加粗 1 _删除线 倾斜 2 加粗 2_ 和 __删除线 倾斜 2 加粗 2__ _删除线 倾斜 2 加粗 1_ 和 删除线 倾斜 2 加粗 1 删除线 倾斜 1 加粗 2 和 __删除线 倾斜 1 加粗 2__ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:8:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"6. 图片 Web image ![Web Picture](https://static.dillonzq.com/images/20190817130904-U6cPUk.jpg \"Web Picture\") Local image ![Local Picture](/images/Apple-Devices-Preview.png) contact@revolunet.com @revolunet Issue #1 https://github.com/revolunet/sublimetext-markdown-preview/ This is a link https://github.com/revolunet/sublimetext-markdown-preview/. This is a link \"https://github.com/revolunet/sublimetext-markdown-preview/\". With this link (https://github.com/revolunet/sublimetext-markdown-preview/), it still works. Web image Web PictureWeb Picture \" Web Picture Local image https://www.google.com contact@revolunet.com @revolunet Issue #1 https://github.com/revolunet/sublimetext-markdown-preview/ This is a link https://github.com/revolunet/sublimetext-markdown-preview/. This is a link “https://github.com/revolunet/sublimetext-markdown-preview/\". With this link (https://github.com/revolunet/sublimetext-markdown-preview/), it still works. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:9:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Abbreviation Abbreviations source are found in a separate markdown file specified in frontmatter. The HTML specification is maintained by the W3C. *[HTML]: Hyper Text Markup Language *[W3C]: World Wide Web Consortium The HTML specification is maintained by the W3C. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:10:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Unordered List Unordered List - item 1 * item A * item B more text + item a + item b + item c * item C - item 2 - item 3 Unordered List item 1 item A item B more text item a item b item c item C item 2 item 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:11:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Ordered List Ordered List 1. item 1 1. item A 2. item B more text 1. item a 2. item b 3. item c 3. item C 2. item 2 3. item 3 Ordered List item 1 item A item B more text item a item b item c item C item 2 item 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:12:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Mixed Lists Really Mixed Lists should break with sane_lists on. Mixed Lists - item 1 * [X] item A * [ ] item B more text 1. item a 2. itemb 3. item c * [X] item C - item 2 - item 3 Really Mixed Lists - item 1 * [X] item A - item B more text 1. item a + itemb + [ ] item c 3. item C 2. item 2 - [X] item 3 Mixed Lists item 1 item A item B more text item a itemb item c item C item 2 item 3 Really Mixed Lists item 1 item A item B more text item a itemb item c item C item 2 item 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:13:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Blocks This is a block. This is more of a block. This is a block. This is more of a block. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:14:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Block Quotes \u003e This is a block quote \u003e\u003e How does it look? This is a block quote. How does it look? I think it looks good. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:15:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Fenced Block Assuming guessing is not enabled. ``` // Fenced **without** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } ``` ```javascript // Fenced **with** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } ``` // Fenced **without** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } // Fenced **with** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:16:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Tables | _颜色_ | 水果 | 蔬菜 | | ------------- |:---------------:| -----------------:| | red | *苹果* | [辣椒](#) | | ~~橙色~~ | 橘子 | **胡萝卜** | | 绿色 | ~~***梨子***~~ | 菠菜 | 颜色 水果 蔬菜 red 苹果 辣椒 橙色 橘子 胡萝卜 绿色 梨子 菠菜 Class or Enum Year Month Day Hours Minutes Seconds* Zone Offset Zone ID toString Output Where Discussed Instant 2013-08-20T15:16:26.355Z Instant Class LocalDate 2013-08-20 Date Classes LocalDateTime 2013-08-20T08:16:26.937 Date and Time Classes ZonedDateTime 2013-08-21T00:16:26.941+09:00[Asia/Tokyo] Time Zone and Offset Classes LocalTime 08:16:26.943 Date and Time Classes MonthDay --08-20 Date Classes Year 2013 Date Classes YearMonth 2013-08 Date Classes Month AUGUST DayOfWeek and Month Enums OffsetDateTime 2013-08-20T08:16:26.954-07:00 Time Zone and Offset Classes OffsetTime 08:16:26.957-07:00 Time Zone and Offset Classes Duration ** ** ** PT20H (20 hours) Period and Duration Period *** *** P10D (10 days) Period and Duration ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:17:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Smart Strong Text with double__underscore__words. __Strong__ still works. __this__works__too__ Text with double__underscore__words. Strong still works. this__works__too ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:18:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Smarty \"double quotes\" 'single quotes' da--sh elipsis... “double quotes” ‘single quotes’ da–sh elipsis… ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:19:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Neseted Fences ``` This will still be parsed as a normal indented code block. ``` ``` This will still be parsed as a fenced code block. ``` - This is a list that contains multiple code blocks. - Here is an indented block ``` This will still be parsed as a normal indented code block. ``` - Here is a fenced code block: ``` This will still be parsed as a fenced code block. ``` \u003e ``` \u003e Blockquotes? \u003e Not a problem! \u003e ``` ``` This will still be parsed as a normal indented code block. ``` This will still be parsed as a fenced code block. This is a list that contains multiple code blocks. Here is an indented block ``` This will still be parsed as a normal indented code block. ``` Here is a fenced code block: This will still be parsed as a fenced code block. Blockquotes? Not a problem! ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:20:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Github Emoji This is a test for emoji 😄. The emojis are images linked to github assets :octocat:. This is a test for emoji 😄. The emojis are images linked to github assets :octocat:. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"People 👍👎👽👼💢😠😧😲👶💙😊💥🙇:bowtie:👦👰💔👤👥👏😰💥😖😕👷👮👫💑💏😢😿💘💃👯💨😞😥💫😵💧👂❗😑👀👊👪😨:feelsgood:🐾:finnadie:🔥✊😳😦🖕👧:goberserk::godmode:💚❕❔😬😄😀💂💇✋💩🙉❤😍😻💓💗:hurtrealbad:😯👿💁😇👺👹😂😹💏😗😽😚😘😙😆👄💌👨👲👳😷💆🤘💪🎵💅:neckbeard:😐🙅😶👃🎶👌🙆👴👵👐😮😔😣🙍👱🙎👇👈👉☝👆💩😾🙏👸👊💜❓😡:rage1::rage2::rage3::rage4:✋🙌🙋☺😌💞🏃🏃😆😱🙀🙈💩💀😴😪😄😸😃😺😈😏😼😭✨💖🙊💬⭐🌟😛😝😜🕶:suspect:😓💦😅💭👎👍😫👅😤:trollface:💕👬👭😒✌🚶👋😩😉👩😟💛😋💤 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Nature 🐜🐤🐻🐝🐞🐦🌼🐡🐗💐🐛🌵🐪🐈🐈🌸🌰🐔☁🐄🐄🌙🐊🌀🌳🐕🐕🐬🐉🐲🐪🌾🌍🌎🌏🐘🌲🍂🌓🌛🐟🌁🍀🐸🌕🌝🌐🐐🐹🐥🐣🌿🌺🐝🐎🐨🌗🌜🍃🐆🍁🌌🐒🐵🌔🐁🐁🍄🌑🌚🌃🌊:octocat:🐙🐂🌴🐼⛅🐾🐧🐖🐖🐽🐩🐇🐇🐎🐏🐀🐓🌹🌱🐑🐚🐌🐍❄☃:squirrel:🌞🌻☀🐅🐅🐠🌷🐢☂🌋🌘🌖🐃🌒🌔🐋🐋🐺⚡ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Objects 🎱⏰🍎🎨👟🍼🎈🎍🍌📊⚾🏀🛀🛁🔋🍺🍻🔔🍱🚴👙🎂🃏✒📘💣📖🔖📑📚👢🎳🍞💼💡🍰📅📲📷🍬📇💿📉📈🍒🍫🎄🎬📋📕🔐🌂♣🍸☕💻🎊🍪🌽💳👑🔮🍛🍮🍡🎯📅♦💵🎎🚪🍩👗📀📧🥚🍆🔌✉️✉📩💶👓📠📁🎆🍥🎣🎏🔦🐬💾🎴🏈👣🍴🍤🍟🎲💎👻🎁💝⛳🍇🍏📗🎸🔫🍔🔨👜🎧♥🔆👠🔪🍯🏇⌛⏳🍨🍦📥📨📱🎃👖🔑👘🏮📒🍋💄🔒🔏🍭➿🔊📢🔅🔍🔎🀄📫📪📬📭👞🍖📣🍈📝🎤🔬💽💸💰🎓🚵🎥🎹🎼🔇📛👔📰🔕📓📔🔩🍢📖📂📙📤📦📄📃📟📎🍑🍐✏✏☎️💊🍍🍕📯📮👝🍗💷👛📌📻🍜🎀🍚🍙🍘🎑💍🏉🎽🍶👡🎅🛰🎷🎒✂📜💺🍧👕👞🚿🎿🚬🏂⚽🔉👾♠🍝❇🎇🔈🍲📏🍓🏄🍣🍠🏊💉🎉🎋🍊🍵☎📞🔭🎾🚽🍅🎩📐🏆🍹🎺👕📺🔓📼📹🎮🎻⌚🍉🎐🍷👚👒🔧💴 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:3","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Places 🚡✈🚑⚓🚛🏧🏦💈🔰🚲🚙⛵️🌉🚅🚄🚌🚏🚗🎠🏁⛪🎪🌇🌇🇨🇳🚧🏪🎌🇩🇪🏬🇪🇸🏰🏤🏭🎡🚒⛲🇫🇷⛽🇬🇧🚁🏥🏨♨🏠🏡🇮🇹🏮🗾🏯🇯🇵🇰🇷🚈🏩🚐🚝🗻🚠🚞🗿🏢🚘🚍🚔🚖🎭🚓🏤🚃🌈🚗🚀🎢🚨📍🚣🇷🇺⛵🏫🚢🎰🚤🌠🚉🗽🚂🌅🌄🚟🚕⛺🎫🗼🚜🚥🚆🚆🚊🚩🚎🚚🇬🇧🇺🇸🚦⚠💒 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:4","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Symbols 💯🔢🅰🆎🔤🔡🉑♒♈◀⏬⏫⬇🔽▶⤵⤴⬅↙↘➡↪⬆↕🔼↖↗🔃🔄🅱🚼🔙🛄☑‼⚫⬛◾◼▪🔲♋🔠♑💹🚸🎦🆑🕐🕙🕥🕚🕦🕛🕧🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤㊗🆒©➰💱🛃💠🚯8️⃣✴✳🔚⏩5️⃣4️⃣🆓♊#️⃣💟✔➗💲❗️➖✖➕🆔🉐ℹ⁉🔟🈁🔵🔷🔶🛅↔↩♌♎🔗ⓜ🚹🚇📴❎🆕🆖9️⃣🚳⛔🚫📵🚷🚭🚱⭕🅾🆗🔛1️⃣⛎🅿〽🛂♓🚰🚮🔘♻🔴®🔁🔂🚻⏪🈂♐♏㊙7️⃣:shipit:📶6️⃣🔯🔹🔸🔺🔻🔜🆘🔣♉3️⃣™🔝🔱🔀2️⃣🈹🈴🈺🈯🈷🈶🈵🈚🈸🈲🈳🔞🆙📳♍🆚〰🚾♿✅⚪💮⬜◽◻▫🔳🚺❌0️⃣ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:5","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Insert ^^insert^^ ^^*insert 倾斜*^^ *^^insert 倾斜 2^^* ^^_insert 倾斜_^^ _^^insert 倾斜 2^^_ ^^**insert 加粗**^^ **^^insert 加粗 2^^** ^^__insert 加粗__^^ __^^insert 加粗 2^^__ ^^***insert 倾斜 加粗***^^ ***^^insert 倾斜 加粗 2^^*** ^^___insert 倾斜 加粗___^^ ___^^insert 倾斜 加粗 2^^___ **^^*insert 倾斜 加粗*^^** *^^**insert 倾斜 加粗 2**^^* __^^_insert 倾斜 加粗_^^__ _^^__insert 倾斜 加粗 2__^^_ **^^_insert 倾斜 加粗_^^** _^^**insert 倾斜 加粗 2**^^_ __^^*insert 倾斜 加粗*^^__ *^^__insert 倾斜 加粗 2__^^* ^^insert^^ ^^insert 倾斜^^ ^^insert 倾斜 2^^ ^^_insert 倾斜_^^ ^^insert 倾斜 2^^ ^^insert 加粗^^ ^^insert 加粗 2^^ ^^__insert 加粗__^^ ^^insert 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ^^___insert 倾斜 加粗___^^ ^^insert 倾斜 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ^^_insert 倾斜 加粗_^^ ^^__insert 倾斜 加粗 2__^^ ^^_insert 倾斜 加粗_^^ ^^insert 倾斜 加粗 2^^ ^^insert 倾斜 加粗^^ ^^__insert 倾斜 加粗 2__^^ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:22:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Admonition Admonition note This is the content of the admonition. Admonition abstract This is the content of the admonition. Admonition info This is the content of the admonition. Admonition tip This is the content of the admonition. Admonition success This is the content of the admonition. Admonition question This is the content of the admonition. Admonition warning This is the content of the admonition. Admonition failure This is the content of the admonition. Admonition danger This is the content of the admonition. Admonition bug This is the content of the admonition. Admonition example This is the content of the admonition. Admonition quote This is the content of the admonition. Admonition This is the content of the admonition. 这是一个基本的数字脚注 ↩︎ 带有 “label” 标签的脚注 ↩︎ 下定义的脚注 ↩︎ LoveIt 主题 ↩︎ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:23:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["Kubernetes"],"content":"环境 hostname ip system master 192.168.33.10 CentOS7 node1 192.168.33.11 CentOS7 node2 192.168.33.12 CentOS7 node3 192.168.33.13 CentOS7 node4 192.168.33.14 CentOS7 node5 192.168.33.15 CentOS7 ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"所有节点上操作 [root@master install]# cat preENV.sh #!/bin/bash # 关闭防火墙 systemctl stop firewalld \u0026\u0026 systemctl disable firewalld # 关闭SELINUX setenforce 0 \u0026\u0026 sed -i \"s/SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config # 关闭Swap swapoff -a \u0026\u0026 sed -i \"s/\\/dev\\/mapper\\/centos-swap/\\#\\/dev\\/mapper\\/centos-swap/g\" /etc/fstab [root@master ~]# vim /etc/sysctl.d/k8s.conf [root@master ~]# cat /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 [root@master ~]# modprobe br_netfilter \u0026\u0026 sysctl -p /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 [root@master ~]# wget -O /etc/yum.repos.d/CentOS7-Aliyun.repo http://mirrors.aliyun.com/repo/Centos-7.repo --2019-06-30 04:26:32-- http://mirrors.aliyun.com/repo/Centos-7.repo Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 116.177.250.229, 116.177.250.233, 60.28.226.4, ... Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|116.177.250.229|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 2523 (2.5K) [application/octet-stream] Saving to: ‘/etc/yum.repos.d/CentOS7-Aliyun.repo’ 100%[============================================================================\u003e] 2,523 --.-K/s in 0s 2019-06-30 04:26:32 (296 MB/s) - ‘/etc/yum.repos.d/CentOS7-Aliyun.repo’ saved [2523/2523] root@master ~]# sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 [root@master ~]# sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo [root@master ~]# yum install docker-ce -y [root@master ~]# systemctl enable docker \u0026\u0026 systemctl start docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. [root@master ~]# mkdir -p /etc/docker [root@master ~]# sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://gmjjwogo.mirror.aliyuncs.com\"], \"exec-opts\": [\"native.cgroupdriver=systemd\"] } EOF { \"registry-mirrors\": [\"https://gmjjwogo.mirror.aliyuncs.com\"], \"exec-opts\": [\"native.cgroupdriver=systemd\"] } [root@master ~]# sudo systemctl daemon-reload \u0026\u0026 sudo systemctl restart docker [root@master ~]# docker info |grep Cgroup Cgroup Driver: systemd [root@master ~]# # kube-proxy开启ipvs的前置条件 [root@master ~]# cat \u003e /etc/sysconfig/modules/ipvs.modules \u003c\u003cEOF #!/bin/bash modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 EOF [root@master ~]# chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026\u0026 bash /etc/sysconfig/modules/ipvs.modules \u0026\u0026 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 ip_vs_sh 12688 0 ip_vs_wrr 12697 0 ip_vs_rr 12600 0 ip_vs 145497 6 ip_vs_rr,ip_vs_sh,ip_vs_wrr nf_conntrack_ipv4 15053 2 nf_defrag_ipv4 12729 1 nf_conntrack_ipv4 nf_conntrack 133095 7 ip_vs,nf_nat,nf_nat_ipv4,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_netlink,nf_conntrack_ipv4 libcrc32c 12644 4 xfs,ip_vs,nf_nat,nf_conntrack [root@master ~]# # 安装kubernetes初始化工具 [root@master ~]# # 使用阿里云的kubernetes源 [root@master ~]# cat \u003c\u003cEOF \u003e /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF [root@master ~]# # 安装k8s 工具 1.15版本 [root@master ~]# yum install -y kubelet kubeadm kubectl Installed: kubeadm.x86_64 0:1.15.0-0 kubectl.x86_64 0:1.15.0-0 kubelet.x86_64 0:1.15.0-0 Dependency Installed: conntrack-tools.x86_64 0:1.4.4-4.el7 cri-tools.x86_64 0:1.12.0-0 kubernetes-cni.x86_64 0:0.7.5-0 libnetfilter_cthelper.x86_64 0:1.0.0-9.el7 libnetfilter_cttimeout.x86_64 0:1.0.0-6.el7 libnetfilter_queue.x86_64 0:1.0.2-2.el7_2 socat.x86_64 0:1.7.3.2-2.el7 Complete! [root@master ~]# # 启动 kubelet [root@master ~]# systemctl enable kubelet \u0026\u0026 systemctl start kubelet Created ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"主节点操作 [root@master install]# vim installK8sMasterImage.sh [root@master install]# cat installK8sMasterImage.sh #!/bin/bash set -e KUBE_VERSION=v1.15.0 KUBE_PAUSE_VERSION=3.1 ETCD_VERSION=3.3.10 CORE_DNS_VERSION=1.3.1 GCR_URL=k8s.gcr.io ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/google_containers images=(kube-proxy:${KUBE_VERSION} kube-scheduler:${KUBE_VERSION} kube-controller-manager:${KUBE_VERSION} kube-apiserver:${KUBE_VERSION} pause:${KUBE_PAUSE_VERSION} etcd:${ETCD_VERSION} coredns:${CORE_DNS_VERSION}) for imageName in ${images[@]} ; do docker pull $ALIYUN_URL/$imageName docker tag $ALIYUN_URL/$imageName $GCR_URL/$imageName docker rmi $ALIYUN_URL/$imageName done [root@master install]# chmod +x installK8sMasterImage.sh \u0026\u0026 ./installK8sMasterImage.sh root@master install]# kubeadm init --kubernetes-version=v1.15.0 --apiserver-advertise-address=192.168.33.10 --pod-network-cidr=10.244.0.0/16 [init] Using Kubernetes version: v1.15.0 [preflight] Running pre-flight checks [WARNING Hostname]: hostname \"master\" could not be reached [WARNING Hostname]: hostname \"master\": lookup master on 10.0.2.3:53: no such host [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using 'kubeadm config images pull' [kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\" [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\" [kubelet-start] Activating the kubelet service [certs] Using certificateDir folder \"/etc/kubernetes/pki\" [certs] Generating \"front-proxy-ca\" certificate and key [certs] Generating \"front-proxy-client\" certificate and key [certs] Generating \"ca\" certificate and key [certs] Generating \"apiserver\" certificate and key [certs] apiserver serving cert is signed for DNS names [master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.33.10] [certs] Generating \"apiserver-kubelet-client\" certificate and key [certs] Generating \"etcd/ca\" certificate and key [certs] Generating \"etcd/server\" certificate and key [certs] etcd/server serving cert is signed for DNS names [master localhost] and IPs [192.168.33.10 127.0.0.1 ::1] [certs] Generating \"etcd/healthcheck-client\" certificate and key [certs] Generating \"apiserver-etcd-client\" certificate and key [certs] Generating \"etcd/peer\" certificate and key [certs] etcd/peer serving cert is signed for DNS names [master localhost] and IPs [192.168.33.10 127.0.0.1 ::1] [certs] Generating \"sa\" key and public key [kubeconfig] Using kubeconfig folder \"/etc/kubernetes\" [kubeconfig] Writing \"admin.conf\" kubeconfig file [kubeconfig] Writing \"kubelet.conf\" kubeconfig file [kubeconfig] Writing \"controller-manager.conf\" kubeconfig file [kubeconfig] Writing \"scheduler.conf\" kubeconfig file [control-plane] Using manifest folder \"/etc/kubernetes/manifests\" [control-plane] Creating static Pod manifest for \"kube-apiserver\" [control-plane] Creating static Pod manifest for \"kube-controller-manager\" [control-plane] Creating static Pod manifest for \"kube-scheduler\" [etcd] Creating static Pod manifest for local etcd in \"/etc/kubernetes/manifests\" [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \"/etc/kubernetes/manifests\". This can take up to 4m0s [apiclient] All control plane components are healthy after 26.502984 seconds [upload-config] Storing the configuration used in ConfigMap \"kubeadm-config\" in the \"kube-system\" Namespace [kubelet] Creating a ConfigMap \"kubelet-config-1.15\" in namespace kube-system with the configuration for the kubelets in the cluster [upload-certs] Skipping phase. Please see --upload-certs [mark-control-plane] Marking the node master as control-plane by adding the label \"node-role.kubernetes.io/master=''\" [mark-control-plane] Mar","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"各 Node 节点上处理 [root@node2 install]# vim installK8sNodeImage.sh [root@node5 install]# cat installK8sNodeImage.sh #!/bin/bash set -e KUBE_VERSION=v1.15.0 KUBE_PAUSE_VERSION=3.1 CORE_DNS_VERSION=1.3.1 GCR_URL=k8s.gcr.io ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/google_containers images=(kube-proxy:${KUBE_VERSION} pause:${KUBE_PAUSE_VERSION} coredns:${CORE_DNS_VERSION}) for imageName in ${images[@]} ; do docker pull $ALIYUN_URL/$imageName docker tag $ALIYUN_URL/$imageName $GCR_URL/$imageName docker rmi $ALIYUN_URL/$imageName done [root@node1 ~]# chmod +x installK8sNodeImage.sh \u0026\u0026 ./installK8sNodeImage.sh v1.15.0: Pulling from google_containers/kube-proxy 39fafc05754f: Pull complete db3f71d0eb90: Pull complete b593bfa65f6f: Pull complete Digest: sha256:7b94921f1c64876d3663698ade724fce79b417b32f0e1053976ca68a18fc0cba Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.15.0 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.15.0 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy@sha256:7b94921f1c64876d3663698ade724fce79b417b32f0e1053976ca68a18fc0cba 3.1: Pulling from google_containers/pause cf9202429979: Pull complete Digest: sha256:759c3f0f6493093a9043cc813092290af69029699ade0e3dbe024e968fcb7cca Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/pause@sha256:759c3f0f6493093a9043cc813092290af69029699ade0e3dbe024e968fcb7cca 1.3.1: Pulling from google_containers/coredns e0daa8927b68: Pull complete 3928e47de029: Pull complete Digest: sha256:638adb0319813f2479ba3642bbe37136db8cf363b48fb3eb7dc8db634d8d5a5b Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/coredns@sha256:638adb0319813f2479ba3642bbe37136db8cf363b48fb3eb7dc8db634d8d5a5b [root@node1 ~]# [root@node5 install]# # Node 加入集群 [root@node1 install]# kubeadm join 192.168.33.10:6443 --token sofcoc.j1it9gvn4uxpduo5 \\ \u003e --discovery-token-ca-cert-hash sha256:3a9b79bd92f66a6284322ade27732932888c0f99884596d5f2c9a03d272e475b [preflight] Running pre-flight checks [preflight] Reading configuration from the cluster... [preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml' [kubelet-start] Downloading configuration for the kubelet from the \"kubelet-config-1.15\" ConfigMap in the kube-system namespace [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\" [kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\" [kubelet-start] Activating the kubelet service [kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap... This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run 'kubectl get nodes' on the control-plane to see this node join the cluster. [root@node1 install]# ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:4:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"master 节点操作 [root@master ~]# #将master节点也作为工作节点进行pod部署 [root@master ~]# kubectl taint nodes master node-role.kubernetes.io/master- node/master untainted ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:5:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"打label [root@master temp]# kubectl label node master nodename=master node/master labeled [root@master temp]# kubectl label node node1 nodename=node1 node/node1 labeled [root@master temp]# kubectl label node node2 nodename=node2 node/node2 labeled [root@master temp]# kubectl label node node3 nodename=node3 node/node3 labeled [root@master temp]# kubectl label node node4 nodename=node4 node/node4 labeled [root@master temp]# kubectl label node node5 nodename=node5 node/node5 labeled ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:6:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"测试 vim nginx-deployment.yaml apiVersion:apps/v1kind:Deploymentmetadata:name:nginx-deploymentlabels:app:nginxspec:replicas:1selector:matchLabels:app:nginxtemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginx:1.7.9imagePullPolicy:IfNotPresentports:- containerPort:80name:webprotocol:TCPnodeSelector:nodename:master---apiVersion:v1kind:Servicemetadata:name:nginx-servicelabels:app:nginxspec:ports:- port:80targetPort:8080name:webselector:app-name:nginx---apiVersion:extensions/v1beta1kind:Ingressmetadata:name:nginxnamespace:defaultspec:rules:- host:c4.k8s.comhttp:paths:- path:/nginxbackend:serviceName:nginx-serviceservicePort:8080 [root@master temp]# kubectl apply -f nginx-deployment.yaml deployment.apps/nginx-deployment created service/nginx-service created ingress.extensions/nginx created [root@master temp]# kubectl get service/nginx-service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx-service ClusterIP 10.100.2.78 \u003cnone\u003e 80/TCP 38s [root@master temp]# kubectl get ing NAME HOSTS ADDRESS PORTS AGE nginx c4.k8s.com 80 4m5s [root@master temp]# wget c4.k8s.com --2019-06-30 07:12:18-- http://c4.k8s.com/ Resolving c4.k8s.com (c4.k8s.com)... 208.73.211.177, 208.73.210.202, 208.73.211.165, ... Connecting to c4.k8s.com (c4.k8s.com)|208.73.211.177|:80... connected. HTTP request sent, awaiting response... 302 Found : Moved Temporarily Location: http://1223.dragonparking.com/?site=c4.k8s.com [following] --2019-06-30 07:12:19-- http://1223.dragonparking.com/?site=c4.k8s.com Resolving 1223.dragonparking.com (1223.dragonparking.com)... 46.51.238.1 Connecting to 1223.dragonparking.com (1223.dragonparking.com)|46.51.238.1|:80... connected. HTTP request sent, awaiting response... 302 Moved Temporarily Location: http://park.zunmi.cn/?acct=1223\u0026site=c4.k8s.com [following] --2019-06-30 07:12:21-- http://park.zunmi.cn/?acct=1223\u0026site=c4.k8s.com Resolving park.zunmi.cn (park.zunmi.cn)... 52.197.205.2 Connecting to park.zunmi.cn (park.zunmi.cn)|52.197.205.2|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 1020 [text/html] Saving to: ‘index.html’ 100%[======================================================================================================================================\u003e] 1,020 --.-K/s in 0s 2019-06-30 07:12:22 (93.5 MB/s) - ‘index.html’ saved [1020/1020] [root@master temp]# ll total 8 -rw-r--r--. 1 root root 1020 May 6 23:28 index.html -rw-r--r--. 1 root root 908 Jun 30 07:07 nginx-deployment.yaml [root@master temp]# kubectl delete -f nginx-deployment.yaml deployment.apps \"nginx-deployment\" deleted service \"nginx-service\" deleted ingress.extensions \"nginx\" deleted ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:7:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.图床：https://sm.ms/ 3.原文：https://yq.aliyun.com/articles/706912?spm=a2c4e.11155435.0.0.59853312vRSRSj ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:8:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:9:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"场景 在搭建私有云环境时，我们需要将我们打包的镜像存储在局域网内，而不是把镜像推送到hub.docker.com；一方面是因为安全问题，另一方面在局域网内存储，网速炒鸡快。当然对于私有云搭建，在本地搭建镜像仓库那是必须的。接下来，对我安装Harbor 做一个记录。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:1:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"分析 因为 Harbor 是用 docker 跑起来的，所以我们的机器上必须有 docker 环境，还有比较中要的一点，Harbor 需要使用docker-compose, 所以需要 docker-compose。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:2:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"安装 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"docker 安装 略…（相信你肯定不会怪我） ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:1","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"docker-compose 安装 $ sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose $ docker-compose --version docker-compose version 1.24.0, build 1110ad01 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:2","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"安装Harbor 离线安装版 获取并解压 $ wget https://storage.googleapis.com/harbor-releases/release-1.8.0/harbor-offline-installer-v1.8.0.tgz $ tar xvf harbor-offline-installer-v1.8.0.tgz 解压会生成 Harbor 文件夹 修改配置文件 $ cd Harbor $ vim /Harbor.yaml 需要配置的地方有几处，但最重要的是hostname, hostname 必须指定为域名，不能使localhost,127.0.0.1 这样的地址，别的密码、端口可可定义。如下是我的配置 # Configuration file of Harbor# The IP address or hostname to access admin UI and registry service.# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.hostname:hub.k8s.com# http related confighttp:# port for http, default is 80. If https enabled, this port will redirect to https portport:80# https related config# https:# # https port for harbor, default is 443# port: 443# # The path of cert and key files for nginx# certificate: /your/certificate/path# private_key: /your/private/key/path# Uncomment external_url if you want to enable external proxy# And when it enabled the hostname will no longer used# external_url: https://reg.mydomain.com:8433# The initial password of Harbor admin# It only works in first time to install harbor# Remember Change the admin password from UI after launching Harbor.harbor_admin_password:Harbor12345# Harbor DB configurationdatabase:# The password for the root user of Harbor DB. Change this before any production use.password:root123# The default data volumedata_volume:/data# Harbor Storage settings by default is using /data dir on local filesystem# Uncomment storage_service setting If you want to using external storage# storage_service:# # ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore# # of registry's and chart repository's containers. This is usually needed when the user hosts a internal storage with self signed certificate.# ca_bundle:# # storage backend, default is filesystem, options include filesystem, azure, gcs, s3, swift and oss# # for more info about this configuration please refer https://docs.docker.com/registry/configuration/# filesystem:# maxthreads: 100# # set disable to true when you want to disable registry redirect# redirect:# disabled: false# Clair configurationclair:# The interval of clair updaters, the unit is hour, set to 0 to disable the updaters.updaters_interval:12# Config http proxy for Clair, e.g. http://my.proxy.com:3128# Clair doesn't need to connect to harbor internal components via http proxy.http_proxy:https_proxy:no_proxy:127.0.0.1,localhost,core,registryjobservice:# Maximum number of job workers in job servicemax_job_workers:10chart:# Change the value of absolute_url to enabled can enable absolute url in chartabsolute_url:disabled# Log configurationslog:# options are debug, info, warning, error, fatallevel:info# Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.rotate_count:50# Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.# If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G# are all valid.rotate_size:200M# The directory on your host that store loglocation:/var/log/harbor#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!_version:1.8.0# Uncomment external_database if using external database. Currently only support POSTGRES.# Four databases are needed to be create first by users for Harbor core, Clair, Notary server# and Notary signer. And the tables will be generated automatically when Harbor starting up.# NOTE: external_database is unable to custom attributes individually, you must do them in block.# external_database:# harbor:# host: harbor_db_host# port: harbor_db_port# db_name: harbor_db_name# username: harbor_db_username# password: harbor_db_password# ssl_mode: disable# clair:# host: clair_db_host# port: clair_db_port# db_name: clair_db_name# username: clair_db_username# p","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:3","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"配置/etc/docker/daemon.json 配置此项的目的是让 docker push 可以将镜像推送到私有仓库中 $ vim /etc/docker/daemon.json { \"registry-mirrors\": [\"https://gmjjwogo.mirror.aliyuncs.com\"], \"insecure-registries\": [\"hub.k8s.com\"] # 追加内容，必须符合json规范 } 重启 docker $ systemctl restart docker 将本地golang 镜像推送到私有仓库 $ docker login hub.k8s.com Username: admin Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 为golang 打标签并推送镜像 $ docker tag golang:alpine hub.k8s.com/cms/golang:alpine $ docker push hub.k8s.com/cms/golang:alpine The push refers to repository [hub.k8s.com/cms/golang] 23419e186866: Pushed 1f6ba46a9c52: Pushed 968d46c1d20e: Pushed b87598efb2f0: Pushed f1b5933fe4b5: Pushed alpine: digest: sha256:5ec3232b32e6876c0941d66d8392f667c77ca1ef14cafb85991deea4339b92da size: 1365 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:4","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"小结 Harbor 是一个 docker 镜像私有仓库的解决方案，是基于 docker-compose 运行起来的，使用相对简单。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:4:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"Reference 1.博客：https://guzhongren.github.io/* ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:5:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:6:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Golang"],"content":" go: golang.org/x/sys@v0.0.0-20180905080454-ebe1bf3edb33: unrecognized import path \"golang.orgnrecognized import path \"golang.org/x/sys\" (https fetch: G1: dial tcp 216.239.37.1:443: conneet https://golang.org/x/sys?go-get=1: dial tcp 216.239.37.rty did not properly respond after1:443: connectex: A connection attempt failed because the connected host has failed to respoconnected party did not properly respond after a period of time, or established connection failed because connected : unrecognized import path \"golang.host has failed to respond.) ... go: golang.org/x/crypto@v0.0.0-20180904163835-0709b304e793nected party did not properly respo: unrecognized import path \"golang.org/x/crypto\" (https fed because connected host has failedtch: Get https://golang.org/x/crypto?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.) go: error loading module requirements ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:0:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"如上，不能安装sys和crypto这两个库，用如下方式即可 1手动加入被墙的包（原始包），一定要记住版本号，实在不知道的话，就试试v0.0.0； $ go mod edit -require=golang.org/x/net@v0.0.0 2 用github上的镜像地址替换 $ go mod edit -replace=golang.org/x/crypto@v0.0.0=github.com/golang/crypto@latest $ go mod edit -replace=golang.org/x/sys@v0.0.0=github.com/golang/sys@latest ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.图床：https://sm.ms/ 3.原文：https://yq.aliyun.com/articles/663151?spm=a2c4e.11155435.0.0.3c783312bi9tbU ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":" go: golang.org/x/sys@v0.0.0-20180905080454-ebe1bf3edb33: unrecognized import path \"golang.orgnrecognized import path \"golang.org/x/sys\" (https fetch: G1: dial tcp 216.239.37.1:443: conneet https://golang.org/x/sys?go-get=1: dial tcp 216.239.37.rty did not properly respond after1:443: connectex: A connection attempt failed because the connected host has failed to respoconnected party did not properly respond after a period of time, or established connection failed because connected : unrecognized import path \"golang.host has failed to respond.) ... go: golang.org/x/crypto@v0.0.0-20180904163835-0709b304e793nected party did not properly respo: unrecognized import path \"golang.org/x/crypto\" (https fed because connected host has failedtch: Get https://golang.org/x/crypto?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.) go: error loading module requirements ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:0:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"如上，不能安装sys和crypto这两个库，用如下方式即可 1手动加入被墙的包（原始包），一定要记住版本号，实在不知道的话，就试试v0.0.0； $ go mod edit -require=golang.org/x/net@v0.0.0 2 用github上的镜像地址替换 $ go mod edit -replace=golang.org/x/crypto@v0.0.0=github.com/golang/crypto@latest $ go mod edit -replace=golang.org/x/sys@v0.0.0=github.com/golang/sys@latest ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.图床：https://sm.ms/ 3.原文：https://yq.aliyun.com/articles/663151?spm=a2c4e.11155435.0.0.3c783312bi9tbU ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了golang.org时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["npm"],"content":"引言 我们大多数情况下用到的包都是存放在 npmjs.com 这个网站上的，只要我们安装了Node，我们就可以使用Node自带的npm包来下载你需要的包; 但有时候我们想让我们自己的包或者库私有，哪怎么办呢？很多人就会想到自己搭一个私服，比如Nexus Repository Manager 和 sinopia;　虽然搭建起来不是很困难，尤其是sinopia就是一个npm包，安装灰常简单，但是都需要一台服务器，一台服务… 一台服… 一台… 一… 现在大多数公司肯定有自己的git仓库了，[没有到git？说明你们技术太XXX落后]那么我们何不利用git仓库来存放我们的各种lib呢？ ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:1:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"传统方式 前事不忘，后事之师。先来复习一下怎么从npmjs.com获取包。[这句是我说的] $ npm install XXX ... ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:2:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"git仓库 假如你已经做了一个特别牛逼的库，但是因为只是公司内部使用，比如一些工具库，放出去比如放到npmjs.com上没任何意义的，你可以把这个库整理成一个git的repo,当然打个标签，发个各版本什么的那就更好了。当你把你牛逼的库放在你司的git上后，比如地址是 ssh:git.niubi.com/yourName/niubility.git　或者　https://git.niubi.com/yourName/niubility.git, 接下来就是发大招。 ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:3:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"大招 $ npm install git+ssh:git.niubi.com/yourName/niubility.git ... **#或者** $ npm install git+https://git.niubi.com/yourName/niubility.git ... ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:4:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"隐藏技能[不推荐] ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:5:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"用户名方式 如果你将 npm 注册到自己的git仓库，就可以直接省去域名等一切能定位到该lib的的通用信息。 注册及登录 $ npm adduser --registry http://you.domain.com ... $ npm login --registry http://you.domain.com ... 安装 $ npm install yourName/niubility ... ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:5:1","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"恩，没什么可说的了我真是来测试打赏功能的。 ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:6:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"Reference 1.博客：https://guzhongren.github.io/ 2.图床：https://sm.ms/ 3.原文：https://yq.aliyun.com/articles/655108?spm=a2c4e.11155435.0.0.3c783312bi9tbU ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:7:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:8:0","tags":["npm","git","registry","私服"],"title":"Npm 安装git资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"}]